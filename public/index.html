<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Adam Shanti — Engineering Portfolio</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Engineering projects, experiments, and tools by Adam Shanti." />
  <link rel="icon" href="/favicon.ico" />
  <link rel="stylesheet" href="/publish/style.css" />
</head>
<body>
  <header class="site-header">
    <div class="container">
      <a class="site-logo" href="/">Adam Shanti</a>
      <nav class="site-nav">
        <a href="#projects">Projects</a>
        <a href="#about">About</a>
        <a href="#contact">Contact</a>
        <a class="btn btn-small" href="/Adam_Shanti_Resume.pdf" target="_blank" rel="noopener">Resume</a>
      </nav>
    </div>
  </header>

  <section class="scene-wrap" id="top">
    <canvas id="scene-canvas" aria-hidden="true"></canvas>

    <div class="bg-title" aria-hidden="true">
      <span>crafted for</span>
      <span>aerial excellence</span>
    </div>

    <div class="center-hub">
      <p class="eyebrow">Aerospace Engineer · Builder</p>
      <h1>Adam Shanti</h1>
      <p class="hub-tagline">Rapid prototyping, propulsion test, and mission-scale simulation stitched into one flight-ready toolkit.</p>
      <div class="hub-actions">
        <a class="btn" href="/Adam_Shanti_Resume.pdf" target="_blank" rel="noopener">Resume</a>
        <a class="btn btn-ghost" href="mailto:adam@adamshanti.com">Email</a>
        <a class="btn btn-ghost" href="https://www.linkedin.com/in/..." target="_blank" rel="noopener">LinkedIn</a>
      </div>
      <span class="hint">Move your cursor to orbit · Scroll for details</span>
    </div>

    <div class="island-labels">
      <a class="island-label" style="--x: 50%; --y: 46%;" href="/Adam_Shanti_Resume.pdf" target="_blank" rel="noopener">Resume Hub</a>
      <a class="island-label" style="--x: 24%; --y: 34%;" href="/projects/interceptor.html">Senior Design Interceptor</a>
      <a class="island-label" style="--x: 78%; --y: 36%;" href="/projects/mk4.html">Mk4 Drone Platform</a>
      <a class="island-label" style="--x: 56%; --y: 70%;" href="/projects/leading-edge.html">Leading Edge Extension</a>
    </div>
  </section>

  <main>
    <section id="projects" class="section section-projects">
      <div class="container">
        <div class="section-heading">
          <div>
            <p class="eyebrow">Featured work</p>
            <h2>Projects</h2>
          </div>
          <label class="tag-controls">
            <span>Filter</span>
            <select id="tagFilter" aria-label="Filter projects by tag">
              <option value="all">All</option>
              <option value="aero">Aero</option>
              <option value="propulsion">Propulsion</option>
              <option value="software">Software</option>
              <option value="hardware">Hardware</option>
              <option value="analysis">Analysis</option>
              <option value="controls">Controls</option>
              <option value="design">Design</option>
              <option value="testing">Testing</option>
            </select>
          </label>
        </div>

        <div class="project-grid">
          <article class="card" data-tags="aero design analysis">
            <img src="/images/mk4-thumb.jpg" alt="Mk4 modular UAV thumbnail" loading="lazy" />
            <div class="card-body">
              <h3 class="card-title">Mk4 Modular UAV</h3>
              <p class="card-text">Modular, 3D-printed fixed-wing UAV with supercapacitor power, rib-and-spar wing, and rapid field repair.</p>
              <ul class="tags">
                <li>aero</li><li>design</li><li>analysis</li>
              </ul>
              <div class="card-actions">
                <a class="btn" href="/projects/mk4.html">Case Study</a>
                <a class="btn btn-ghost" href="https://github.com/..." target="_blank" rel="noopener">Code</a>
              </div>
            </div>
          </article>

          <article class="card" data-tags="propulsion testing hardware">
            <img src="/images/engine-test-thumb.jpg" alt="Engine test stand thumbnail" loading="lazy" />
            <div class="card-body">
              <h3 class="card-title">Turbojet Test Stand</h3>
              <p class="card-text">Instrumented test stand with DAQ, safety interlocks, and calibrated thrust measurement for turbojet characterization.</p>
              <ul class="tags">
                <li>propulsion</li><li>testing</li><li>hardware</li>
              </ul>
              <div class="card-actions">
                <a class="btn" href="/projects/turbojet.html">Case Study</a>
                <a class="btn btn-ghost" href="https://youtu.be/..." target="_blank" rel="noopener">Demo</a>
              </div>
            </div>
          </article>

          <article class="card" data-tags="software analysis controls">
            <img src="/images/mission-sim-thumb.jpg" alt="Mission simulation plot thumbnail" loading="lazy" />
            <div class="card-body">
              <h3 class="card-title">Mission Profile Simulator</h3>
              <p class="card-text">Segment-based aircraft mission sim with carpet plots for TSL vs WTOS and fuel split visualizations.</p>
              <ul class="tags">
                <li>software</li><li>analysis</li><li>controls</li>
              </ul>
              <div class="card-actions">
                <a class="btn" href="/projects/mission-sim.html">Case Study</a>
                <a class="btn btn-ghost" href="https://github.com/..." target="_blank" rel="noopener">Repo</a>
              </div>
            </div>
          </article>
        </div>
      </div>
    </section>

    <section id="about" class="section section-about">
      <div class="container">
        <p class="eyebrow">Who I am</p>
        <h2>About</h2>
        <p class="lede">I’m an aerospace engineer focused on propulsion test, conceptual aircraft design, and simulation. I build tooling and rigs that bridge the gap between first sketch and flight-ready data.</p>
        <div class="about-grid">
          <div>
            <h3>Strengths</h3>
            <ul>
              <li>Full-stack prototyping across CAD, firmware, and cloud orchestration.</li>
              <li>High-fidelity test design with instrumentation, sensor fusion, and safety interlocks.</li>
              <li>Mission analysis and controls modeling for multi-segment flight envelopes.</li>
            </ul>
          </div>
          <div>
            <h3>Currently</h3>
            <ul>
              <li>Building flight-worthy infrastructure that scales from lab rigs to high-altitude operations.</li>
              <li>Exploring reusable airframes and rapid repair workflows for field teams.</li>
              <li>Experimenting with virtual mission rehearsal for distributed pilots.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <section id="contact" class="section section-contact">
      <div class="container">
        <p class="eyebrow">Let’s collaborate</p>
        <h2>Contact</h2>
        <p class="lede">Reach out for propulsion test campaigns, mission tooling, or to collaborate on aerial systems.</p>
        <div class="contact-actions">
          <a class="btn" href="mailto:adam@adamshanti.com">adam@adamshanti.com</a>
          <a class="btn btn-ghost" href="https://www.linkedin.com/in/..." target="_blank" rel="noopener">LinkedIn</a>
        </div>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="container">
      <small>© <span id="year"></span> Adam Shanti · Built for the cloud edge</small>
    </div>
  </footer>

  <script>
    document.getElementById('year').textContent = new Date().getFullYear();
    const select = document.getElementById('tagFilter');
    const cards = Array.from(document.querySelectorAll('.project-grid .card'));
    if (select) {
      select.addEventListener('change', () => {
        const tag = select.value;
        cards.forEach(card => {
          const tags = (card.getAttribute('data-tags') || '').split(/\s+/);
          const show = tag === 'all' || tags.includes(tag);
          card.style.display = show ? '' : 'none';
        });
      });
    }
  </script>

  
  <script type="module">
    const root = document.documentElement;
    const sceneWrap = document.querySelector('.scene-wrap');
    const canvas = document.getElementById('scene-canvas');
    const centerHubEl = document.querySelector('.center-hub');
    const bgTitleEl = document.querySelector('.bg-title');
    const projectsSection = document.getElementById('projects');
    const headerEl = document.querySelector('.site-header');
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)');

    function hasWebGL() {
      try {
        const testCanvas = document.createElement('canvas');
        return !!window.WebGLRenderingContext && !!(testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl'));
      } catch (err) {
        return false;
      }
    }

    if (!hasWebGL()) {
      root.classList.add('no-webgl');
      console.warn('WebGL not available; keeping fallback labels visible.');
    } else {
      root.classList.add('has-webgl');
      try {
        const THREE = await import('https://cdn.jsdelivr.net/npm/three@0.156.1/build/three.module.js');

        if (projectsSection) {
          projectsSection.style.opacity = '0';
          projectsSection.style.transform = 'translateY(40px)';
          projectsSection.style.willChange = 'opacity, transform';
        }
        if (centerHubEl) {
          centerHubEl.style.willChange = 'opacity, transform';
        }
        if (bgTitleEl) {
          bgTitleEl.style.willChange = 'opacity, transform';
        }

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.outputColorSpace = THREE.SRGBColorSpace;

        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x070e1f, 14, 48);

        const camera = new THREE.PerspectiveCamera(50, canvas.clientWidth / canvas.clientHeight, 0.1, 120);
        camera.position.set(0, 3.4, 9.8);

        const ambient = new THREE.AmbientLight(0xe7f2ff, 0.55);
        scene.add(ambient);

        const keyLight = new THREE.DirectionalLight(0xfff3d1, 1.9);
        keyLight.position.set(6, 8, 6);
        scene.add(keyLight);

        const rimLight = new THREE.DirectionalLight(0x84b9ff, 1.4);
        rimLight.position.set(-6, 4, -5);
        scene.add(rimLight);

        const topLight = new THREE.SpotLight(0xb3e8ff, 1.1, 40, Math.PI / 4.2, 0.6, 1.5);
        topLight.position.set(0, 7, 2);
        topLight.target.position.set(0, 0, 0);
        scene.add(topLight, topLight.target);

        const stage = new THREE.Group();
        stage.position.y = 0.45;
        scene.add(stage);

        const stageBasePosition = stage.position.clone();
        const stageBaseScale = stage.scale.x;
        const easeInOut = t => t * t * (3 - 2 * t);
        let scrollProgress = 0;
        let scrollProgressTarget = 0;
        let scrollNeedsUpdate = true;
        const headerHeight = headerEl ? headerEl.offsetHeight : 0;

        const updateScrollTarget = () => {
          const rect = sceneWrap.getBoundingClientRect();
          const total = Math.max(sceneWrap.offsetHeight - window.innerHeight * 0.6, 1);
          const distance = THREE.MathUtils.clamp(headerHeight - rect.top, 0, total);
          scrollProgressTarget = distance / total;
        };

        const requestScrollUpdate = () => { scrollNeedsUpdate = true; };
        window.addEventListener('scroll', requestScrollUpdate, { passive: true });

        const gradientBacker = new THREE.Mesh(
          new THREE.PlaneGeometry(30, 16),
          new THREE.MeshBasicMaterial({ color: 0x1a2f56, transparent: true, opacity: 0.6 })
        );
        gradientBacker.position.set(0, 3, -12);
        scene.add(gradientBacker);

        const groundGlow = new THREE.Mesh(
          new THREE.CircleGeometry(11.5, 96),
          new THREE.MeshBasicMaterial({ color: 0x133063, transparent: true, opacity: 0.48 })
        );
        groundGlow.rotation.x = -Math.PI / 2;
        groundGlow.position.y = -1.7;
        stage.add(groundGlow);

        const auraRing = new THREE.Mesh(
          new THREE.RingGeometry(6.6, 7.6, 64),
          new THREE.MeshBasicMaterial({ color: 0x68d8ff, transparent: true, opacity: 0.32, side: THREE.DoubleSide })
        );
        auraRing.rotation.x = -Math.PI / 2;
        auraRing.position.y = -0.25;
        stage.add(auraRing);

        const floatingItems = [];
        const registerFloat = (group, amplitude = 0.2, speed = 1, spin = 0) => {
          floatingItems.push({
            group,
            baseY: group.position.y,
            amplitude,
            speed,
            offset: Math.random() * Math.PI * 2,
            spin
          });
        };

        const heroExplodePieces = [];
        const registerHeroPiece = (mesh, { offset = new THREE.Vector3(), rotation = new THREE.Euler(), scale = 0 } = {}) => {
          heroExplodePieces.push({
            mesh,
            basePosition: mesh.position.clone(),
            baseRotation: mesh.rotation.clone(),
            baseScale: mesh.scale.clone(),
            offset,
            rotation,
            scale
          });
        };

        const interactives = [];
        const interactiveMeshes = [];
        const registerInteractive = (mesh, config) => {
          mesh.userData.interactive = config;
          interactiveMeshes.push(mesh);
          interactives.push(config);
        };

        const heroBadgeMaterial = new THREE.MeshStandardMaterial({
          color: 0xffd479,
          emissive: 0xffb13a,
          emissiveIntensity: 0.45,
          metalness: 0.3,
          roughness: 0.5
        });

        const buildHeroShowcase = () => {
          const group = new THREE.Group();

          const baseLower = new THREE.Mesh(
            new THREE.CylinderGeometry(4.6, 5.2, 0.6, 80),
            new THREE.MeshStandardMaterial({ color: 0x1c2f56, metalness: 0.35, roughness: 0.75 })
          );
          baseLower.position.y = 0.1;
          group.add(baseLower);

          const baseUpper = new THREE.Mesh(
            new THREE.CylinderGeometry(3.6, 4.1, 0.52, 64),
            new THREE.MeshStandardMaterial({ color: 0x2a45a4, metalness: 0.38, roughness: 0.62, emissive: 0x142b6b, emissiveIntensity: 0.2 })
          );
          baseUpper.position.y = 0.72;
          group.add(baseUpper);

          const terrace = new THREE.Mesh(
            new THREE.BoxGeometry(5.4, 0.34, 2.8),
            new THREE.MeshStandardMaterial({ color: 0x3659d0, metalness: 0.42, roughness: 0.48 })
          );
          terrace.position.set(0.3, 1.15, 0.2);
          terrace.rotation.y = 0.22;
          group.add(terrace);
          registerHeroPiece(terrace, { offset: new THREE.Vector3(0.4, 0.6, -0.5), rotation: new THREE.Euler(0, 0.18, 0) });

          const archBack = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 2.4, 2.6),
            new THREE.MeshStandardMaterial({ color: 0x6a7dff, metalness: 0.28, roughness: 0.55 })
          );
          archBack.position.set(0.6, 1.8, -0.7);
          group.add(archBack);
          registerHeroPiece(archBack, { offset: new THREE.Vector3(0.3, 0.7, -0.2) });

          const archCurve = new THREE.Mesh(
            new THREE.TorusGeometry(1.2, 0.16, 24, 100, Math.PI),
            new THREE.MeshStandardMaterial({ color: 0x7f8dff, metalness: 0.25, roughness: 0.45 })
          );
          archCurve.position.set(0.6, 2.2, -0.7);
          archCurve.rotation.set(Math.PI / 2, 0, Math.PI);
          group.add(archCurve);
          registerHeroPiece(archCurve, { offset: new THREE.Vector3(0.2, 0.8, -0.25) });

          const archVines = new THREE.Mesh(
            new THREE.ConeGeometry(0.32, 1.6, 24, 1, true),
            new THREE.MeshStandardMaterial({ color: 0x6cf5ae, transparent: true, opacity: 0.7, side: THREE.DoubleSide })
          );
          archVines.position.set(0.2, 1.6, -0.9);
          group.add(archVines);
          registerHeroPiece(archVines, { offset: new THREE.Vector3(0, 0.6, -0.4) });

          const seatBase = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.55, 1.6, 12, 24),
            new THREE.MeshStandardMaterial({ color: 0xffa16f, roughness: 0.65, metalness: 0.15 })
          );
          seatBase.rotation.set(Math.PI / 2, 0.3, Math.PI / 16);
          seatBase.position.set(-1.05, 1.05, 0.45);
          group.add(seatBase);
          registerHeroPiece(seatBase, { offset: new THREE.Vector3(-0.5, 0.5, 0.6) });

          const seatBack = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.5, 1.1, 10, 22),
            new THREE.MeshStandardMaterial({ color: 0xffbe99, roughness: 0.6, metalness: 0.2 })
          );
          seatBack.rotation.set(Math.PI / 2, -0.4, -Math.PI / 12);
          seatBack.position.set(-0.9, 1.4, -0.05);
          group.add(seatBack);
          registerHeroPiece(seatBack, { offset: new THREE.Vector3(-0.2, 0.42, 0.4) });

          const laptopBase = new THREE.Mesh(
            new THREE.BoxGeometry(0.98, 0.08, 0.68),
            new THREE.MeshStandardMaterial({ color: 0x1a2646, roughness: 0.25, metalness: 0.7 })
          );
          laptopBase.position.set(-0.35, 1.28, 0.62);
          laptopBase.rotation.set(-0.2, 0.4, 0.05);
          group.add(laptopBase);
          registerHeroPiece(laptopBase, { offset: new THREE.Vector3(0.15, 0.48, 0.35), rotation: new THREE.Euler(-0.15, 0.18, -0.12) });

          const laptopScreen = new THREE.Mesh(
            new THREE.BoxGeometry(0.92, 0.6, 0.05),
            new THREE.MeshStandardMaterial({ color: 0x9fd8ff, emissive: 0x58c8ff, emissiveIntensity: 0.65, roughness: 0.2 })
          );
          laptopScreen.position.set(-0.22, 1.56, 0.55);
          laptopScreen.rotation.set(1.18, 0.4, 0.05);
          group.add(laptopScreen);
          registerHeroPiece(laptopScreen, { offset: new THREE.Vector3(0.18, 0.62, 0.48), rotation: new THREE.Euler(0.2, 0.25, 0.08) });

          const planningTable = new THREE.Mesh(
            new THREE.CylinderGeometry(0.95, 0.95, 0.16, 40),
            new THREE.MeshStandardMaterial({ color: 0x4f6ee3, metalness: 0.4, roughness: 0.38 })
          );
          planningTable.position.set(1.4, 1.24, 0.4);
          group.add(planningTable);
          registerHeroPiece(planningTable, { offset: new THREE.Vector3(0.6, 0.45, 0.3) });

          const blueprint = new THREE.Mesh(
            new THREE.PlaneGeometry(1.2, 0.82),
            new THREE.MeshStandardMaterial({ color: 0xb8ebff, roughness: 0.3, metalness: 0.15, transparent: true, opacity: 0.88 })
          );
          blueprint.position.set(1.4, 1.36, 0.4);
          blueprint.rotation.set(-Math.PI / 2.4, 0.26, 0);
          group.add(blueprint);
          registerHeroPiece(blueprint, { offset: new THREE.Vector3(0.58, 0.5, 0.38), rotation: new THREE.Euler(-0.2, 0.15, 0) });

          const pointerBeacon = new THREE.Mesh(
            new THREE.TorusGeometry(0.42, 0.08, 22, 80),
            heroBadgeMaterial
          );
          pointerBeacon.rotation.x = Math.PI / 2;
          pointerBeacon.position.set(0.6, 1.18, -0.2);
          group.add(pointerBeacon);
          registerHeroPiece(pointerBeacon, { offset: new THREE.Vector3(0, 0.45, 0), scale: 0.18 });

          const heroHotspot = new THREE.Mesh(
            new THREE.CircleGeometry(2.8, 64),
            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.02, depthWrite: false })
          );
          heroHotspot.rotation.x = -Math.PI / 2;
          heroHotspot.position.set(0.35, 0.76, 0.25);
          group.add(heroHotspot);

          registerInteractive(heroHotspot, {
            id: 'resume-hub',
            onHover: isHovering => {
              heroBadgeMaterial.emissiveIntensity = isHovering ? 1.1 : 0.45;
            },
            onClick: () => window.open('/Adam_Shanti_Resume.pdf', '_blank', 'noopener')
          });

          return group;
        };

        const buildInterceptorIsland = () => {
          const group = new THREE.Group();

          const base = new THREE.Mesh(
            new THREE.CylinderGeometry(2.25, 2.6, 0.34, 48),
            new THREE.MeshStandardMaterial({ color: 0x273958, metalness: 0.4, roughness: 0.6 })
          );
          base.position.y = 0.17;
          group.add(base);

          const deck = new THREE.Mesh(
            new THREE.CylinderGeometry(2.05, 2.2, 0.24, 48),
            new THREE.MeshStandardMaterial({ color: 0x4a66c0, metalness: 0.4, roughness: 0.4 })
          );
          deck.position.y = 0.46;
          group.add(deck);

          const fuselage = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.32, 2.4, 20, 32),
            new THREE.MeshStandardMaterial({ color: 0xbfd6ff, metalness: 0.55, roughness: 0.22 })
          );
          fuselage.rotation.set(0.08, Math.PI / 2, 0);
          fuselage.position.set(0, 1.16, 0);
          group.add(fuselage);

          const wing = new THREE.Mesh(
            new THREE.BoxGeometry(2.8, 0.12, 1.48),
            new THREE.MeshStandardMaterial({ color: 0x5f7bf0, metalness: 0.5, roughness: 0.3 })
          );
          wing.rotation.set(0.12, 0, 0.18);
          wing.position.set(0, 1.02, -0.1);
          group.add(wing);

          const canard = new THREE.Mesh(
            new THREE.BoxGeometry(1.1, 0.08, 0.42),
            new THREE.MeshStandardMaterial({ color: 0xffd584, metalness: 0.38, roughness: 0.28 })
          );
          canard.rotation.set(0.15, 0, -0.2);
          canard.position.set(0.32, 1.28, 0.18);
          group.add(canard);

          const tail = new THREE.Mesh(
            new THREE.BoxGeometry(0.12, 0.9, 0.9),
            new THREE.MeshStandardMaterial({ color: 0x485a98, metalness: 0.35, roughness: 0.4 })
          );
          tail.position.set(-0.95, 1.42, -0.2);
          tail.rotation.set(0, 0.3, 0);
          group.add(tail);

          const plume = new THREE.Mesh(
            new THREE.ConeGeometry(0.2, 0.6, 24),
            new THREE.MeshStandardMaterial({ color: 0xff8a5b, emissive: 0xff6434, emissiveIntensity: 0.35, transparent: true, opacity: 0.85 })
          );
          plume.position.set(1.2, 1.0, -0.12);
          plume.rotation.set(Math.PI / 2, 0, 0.15);
          group.add(plume);

          return group;
        };

        const buildMk4Island = () => {
          const group = new THREE.Group();

          const base = new THREE.Mesh(
            new THREE.CylinderGeometry(2.1, 2.5, 0.32, 48),
            new THREE.MeshStandardMaterial({ color: 0x243659, metalness: 0.4, roughness: 0.6 })
          );
          base.position.y = 0.16;
          group.add(base);

          const deck = new THREE.Mesh(
            new THREE.CylinderGeometry(1.9, 2.05, 0.24, 48),
            new THREE.MeshStandardMaterial({ color: 0x4f7fe9, metalness: 0.42, roughness: 0.4 })
          );
          deck.position.y = 0.44;
          group.add(deck);

          const wing = new THREE.Mesh(
            new THREE.BoxGeometry(2.4, 0.12, 0.6),
            new THREE.MeshStandardMaterial({ color: 0x92d8ff, metalness: 0.58, roughness: 0.24 })
          );
          wing.position.y = 1.02;
          group.add(wing);

          const fuselage = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.32, 1.1, 18, 32),
            new THREE.MeshStandardMaterial({ color: 0xcde9ff, metalness: 0.6, roughness: 0.22 })
          );
          fuselage.rotation.set(Math.PI / 2, 0.18, 0);
          fuselage.position.set(0.1, 1.1, 0);
          group.add(fuselage);

          const tailBoom = new THREE.Mesh(
            new THREE.CylinderGeometry(0.14, 0.22, 0.8, 20),
            new THREE.MeshStandardMaterial({ color: 0x6f9fff, metalness: 0.48, roughness: 0.28 })
          );
          tailBoom.rotation.set(Math.PI / 2, 0, 0);
          tailBoom.position.set(-0.75, 1.34, 0);
          group.add(tailBoom);

          const payload = new THREE.Mesh(
            new THREE.TorusGeometry(0.32, 0.09, 18, 60),
            new THREE.MeshStandardMaterial({ color: 0xffae76, metalness: 0.5, roughness: 0.4 })
          );
          payload.rotation.x = Math.PI / 2;
          payload.position.set(0.92, 0.94, 0.18);
          group.add(payload);

          const sensorPod = new THREE.Mesh(
            new THREE.CylinderGeometry(0.18, 0.18, 0.5, 24),
            new THREE.MeshStandardMaterial({ color: 0xffc8a0, metalness: 0.35, roughness: 0.45 })
          );
          sensorPod.rotation.set(Math.PI / 2, 0, 0.1);
          sensorPod.position.set(0.92, 1.02, 0.18);
          group.add(sensorPod);

          return group;
        };

        const buildLeadingEdgeIsland = () => {
          const group = new THREE.Group();

          const base = new THREE.Mesh(
            new THREE.CylinderGeometry(2.3, 2.6, 0.3, 48),
            new THREE.MeshStandardMaterial({ color: 0x1b3d44, metalness: 0.38, roughness: 0.6 })
          );
          base.position.y = 0.15;
          group.add(base);

          const deck = new THREE.Mesh(
            new THREE.CylinderGeometry(2.1, 2.2, 0.24, 48),
            new THREE.MeshStandardMaterial({ color: 0x3f8f9f, metalness: 0.4, roughness: 0.42 })
          );
          deck.position.y = 0.42;
          group.add(deck);

          const wingSection = new THREE.Mesh(
            new THREE.BoxGeometry(2.8, 0.18, 0.72),
            new THREE.MeshStandardMaterial({ color: 0x8de6f1, metalness: 0.45, roughness: 0.32 })
          );
          wingSection.rotation.set(-0.22, 0.32, 0.08);
          wingSection.position.set(0.1, 1.02, 0);
          group.add(wingSection);

          const leadingEdge = new THREE.Mesh(
            new THREE.CylinderGeometry(0.12, 0.12, 2.9, 32),
            new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.6, roughness: 0.18 })
          );
          leadingEdge.rotation.set(0, 0, Math.PI / 2);
          leadingEdge.position.set(0.12, 1.18, 0.12);
          group.add(leadingEdge);

          const strut = new THREE.Mesh(
            new THREE.CylinderGeometry(0.09, 0.09, 1.2, 18),
            new THREE.MeshStandardMaterial({ color: 0x5fd6ff, metalness: 0.5, roughness: 0.3 })
          );
          strut.rotation.set(Math.PI / 2.1, 0.1, 0.4);
          strut.position.set(-0.88, 1.38, -0.06);
          group.add(strut);

          const flowViz = new THREE.Mesh(
            new THREE.PlaneGeometry(1.6, 1.2),
            new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.32 })
          );
          flowViz.position.set(0.8, 1.38, -0.22);
          flowViz.rotation.set(-Math.PI / 3, -0.35, 0.24);
          group.add(flowViz);

          const vortex = new THREE.Mesh(
            new THREE.TorusGeometry(0.32, 0.07, 18, 70),
            new THREE.MeshStandardMaterial({ color: 0x9dfef4, emissive: 0x58f8e8, emissiveIntensity: 0.4, transparent: true, opacity: 0.8 })
          );
          vortex.rotation.x = Math.PI / 2;
          vortex.position.set(0.82, 1.54, -0.28);
          group.add(vortex);

          return group;
        };

        const heroShowcase = buildHeroShowcase();
        stage.add(heroShowcase);
        registerFloat(heroShowcase, 0.12, 0.85, 0.0008);

        const interceptorIsland = buildInterceptorIsland();
        interceptorIsland.position.set(-3.5, 0.3, -2.1);
        stage.add(interceptorIsland);
        registerFloat(interceptorIsland, 0.25, 1.12, 0.0016);

        const mk4Island = buildMk4Island();
        mk4Island.position.set(3.3, 0.35, -1.6);
        stage.add(mk4Island);
        registerFloat(mk4Island, 0.22, 0.98, -0.0014);

        const leadingEdgeIsland = buildLeadingEdgeIsland();
        leadingEdgeIsland.position.set(0.9, 0.55, 2.8);
        stage.add(leadingEdgeIsland);
        registerFloat(leadingEdgeIsland, 0.28, 0.9, 0.0012);

        const beacon = new THREE.Mesh(
          new THREE.SphereGeometry(0.42, 24, 24),
          new THREE.MeshStandardMaterial({ color: 0x63d8ff, emissive: 0x2cd4ff, emissiveIntensity: 0.6 })
        );
        beacon.position.set(-1.45, 1.68, 1.8);
        stage.add(beacon);
        registerFloat(beacon, 0.35, 1.5, 0.004);

        const beaconHalo = new THREE.Mesh(
          new THREE.RingGeometry(0.45, 0.65, 64),
          new THREE.MeshBasicMaterial({ color: 0x83f4ff, transparent: true, opacity: 0.45 })
        );
        beaconHalo.rotation.x = Math.PI / 2;
        beaconHalo.position.copy(beacon.position);
        stage.add(beaconHalo);

        const probe = new THREE.Mesh(
          new THREE.CapsuleGeometry(0.18, 0.8, 8, 16),
          new THREE.MeshStandardMaterial({ color: 0xffe69c, metalness: 0.4, roughness: 0.3 })
        );
        probe.rotation.z = -0.6;
        probe.position.set(2.1, 1.4, 1.8);
        stage.add(probe);
        registerFloat(probe, 0.2, 1.4, 0.003);

        const probeRing = new THREE.Mesh(
          new THREE.TorusGeometry(0.34, 0.05, 18, 70),
          new THREE.MeshStandardMaterial({ color: 0xffae6a, metalness: 0.5, roughness: 0.4 })
        );
        probeRing.rotation.x = Math.PI / 2;
        probeRing.position.set(2.1, 1.02, 1.8);
        stage.add(probeRing);

        const starCount = 720;
        const starGeometry = new THREE.BufferGeometry();
        const starPositions = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount; i += 1) {
          starPositions[i * 3] = (Math.random() - 0.5) * 60;
          starPositions[i * 3 + 1] = Math.random() * 28 + 4;
          starPositions[i * 3 + 2] = (Math.random() - 0.5) * 60;
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0x68b7ff, size: 0.08, transparent: true, opacity: 0.55, depthWrite: false });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        const pointer = { x: 0, y: 0 };
        const pointerTarget = { x: 0, y: 0 };
        let idleTimer = 0;

        const updatePointer = event => {
          const rect = sceneWrap.getBoundingClientRect();
          pointerTarget.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          pointerTarget.y = ((event.clientY - rect.top) / rect.height) * 2 - 1;
          idleTimer = 0;
        };

        sceneWrap.addEventListener('pointermove', updatePointer);
        sceneWrap.addEventListener('pointerdown', updatePointer);
        sceneWrap.addEventListener('pointerleave', () => {
          pointerTarget.x = 0;
          pointerTarget.y = 0;
        });

        let hoveredInteractive = null;
        let heroExplodeProgress = 0;
        const raycaster = new THREE.Raycaster();
        const rayPointer = new THREE.Vector2();

        sceneWrap.addEventListener('click', () => {
          if (hoveredInteractive && typeof hoveredInteractive.onClick === 'function') {
            hoveredInteractive.onClick();
          }
        });

        const clock = new THREE.Clock();

        function resizeRenderer() {
          const pixelRatio = Math.min(window.devicePixelRatio, 2);
          const width = canvas.clientWidth;
          const height = canvas.clientHeight;
          if (canvas.width !== Math.floor(width * pixelRatio) || canvas.height !== Math.floor(height * pixelRatio)) {
            renderer.setSize(width, height, false);
            renderer.setPixelRatio(pixelRatio);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
          }
        }

        function render() {
          resizeRenderer();
          const delta = clock.getDelta();
          const elapsed = clock.getElapsedTime();
          idleTimer += delta;

          if (scrollNeedsUpdate) {
            updateScrollTarget();
            scrollNeedsUpdate = false;
          }

          scrollProgress += (scrollProgressTarget - scrollProgress) * 0.08;
          const easedScroll = easeInOut(scrollProgress);
          const liftAmount = easedScroll * 4.6;
          stage.position.y = stageBasePosition.y + liftAmount;
          stage.position.z = stageBasePosition.z - easedScroll * 3.2;
          const scaleFactor = THREE.MathUtils.lerp(stageBaseScale || 1, (stageBaseScale || 1) * 0.76, easedScroll);
          stage.scale.setScalar(scaleFactor);

          if (centerHubEl) {
            const hubOpacity = Math.max(0, 1 - easedScroll * 1.4);
            centerHubEl.style.opacity = hubOpacity.toFixed(3);
            centerHubEl.style.transform = `translate3d(0, ${-easedScroll * 140}px, 0)`;
          }

          if (bgTitleEl) {
            const titleOpacity = Math.max(0.1, 1 - easedScroll * 1.05);
            bgTitleEl.style.opacity = titleOpacity.toFixed(3);
            bgTitleEl.style.transform = `translate3d(0, ${-easedScroll * 180}px, 0)`;
          }

          if (projectsSection) {
            const projectEase = THREE.MathUtils.clamp((scrollProgress - 0.22) / 0.55, 0, 1);
            projectsSection.style.opacity = projectEase.toFixed(3);
            projectsSection.style.transform = `translateY(${40 * (1 - projectEase)}px)`;
          }

          pointer.x += (pointerTarget.x - pointer.x) * 0.08;
          pointer.y += (pointerTarget.y - pointer.y) * 0.08;

          rayPointer.set(pointer.x, -pointer.y);
          raycaster.setFromCamera(rayPointer, camera);
          const hit = raycaster.intersectObjects(interactiveMeshes, false)[0];
          const nextInteractive = hit ? hit.object.userData.interactive : null;
          if (nextInteractive !== hoveredInteractive) {
            if (hoveredInteractive && typeof hoveredInteractive.onHover === 'function') {
              hoveredInteractive.onHover(false);
            }
            hoveredInteractive = nextInteractive || null;
            if (hoveredInteractive && typeof hoveredInteractive.onHover === 'function') {
              hoveredInteractive.onHover(true);
            }
          }

          const heroTarget = hoveredInteractive && hoveredInteractive.id === 'resume-hub' ? 1 : 0;
          heroExplodeProgress += (heroTarget - heroExplodeProgress) * 0.12;
          const heroEase = easeInOut(heroExplodeProgress);
          heroExplodePieces.forEach(piece => {
            piece.mesh.position.copy(piece.basePosition).addScaledVector(piece.offset, heroEase);
            piece.mesh.rotation.set(
              piece.baseRotation.x + piece.rotation.x * heroEase,
              piece.baseRotation.y + piece.rotation.y * heroEase,
              piece.baseRotation.z + piece.rotation.z * heroEase
            );
            if (piece.scale) {
              const targetScale = piece.baseScale.x + piece.scale * heroEase;
              piece.mesh.scale.setScalar(targetScale);
            }
          });

          if (!prefersReducedMotion.matches) {
            if (idleTimer > 6) {
              pointerTarget.x = Math.sin(elapsed * 0.25) * 0.35;
              pointerTarget.y = Math.cos(elapsed * 0.2) * 0.18;
            }

            const pointerInfluence = 1 - easedScroll;
            const targetY = -pointer.x * 0.55 * pointerInfluence;
            const targetX = THREE.MathUtils.clamp(pointer.y * 0.22, -0.2, 0.24) * pointerInfluence;
            stage.rotation.y += (targetY - stage.rotation.y) * 0.05;
            stage.rotation.x += (targetX - stage.rotation.x) * 0.05;

            floatingItems.forEach(item => {
              const bob = Math.sin(elapsed * item.speed + item.offset) * item.amplitude * (1 - easedScroll * 0.85);
              item.group.position.y = item.baseY + bob;
              if (item.spin) {
                item.group.rotation.y += item.spin * (1 - easedScroll * 0.6);
              }
            });

            auraRing.scale.setScalar(1 + Math.sin(elapsed * 0.4) * 0.04);
            beaconHalo.rotation.z += 0.01;
            probeRing.rotation.y += 0.01;
            stars.rotation.y -= 0.0003;
          } else {
            stage.rotation.x += (0 - stage.rotation.x) * 0.08;
            stage.rotation.y += (0 - stage.rotation.y) * 0.08;
          }

          renderer.render(scene, camera);
        }

        renderer.setAnimationLoop(render);

        const handleMotionChange = () => {
          if (prefersReducedMotion.matches) {
            floatingItems.forEach(item => {
              item.group.position.y = item.baseY;
            });
            pointerTarget.x = 0;
            pointerTarget.y = 0;
          }
        };

        prefersReducedMotion.addEventListener?.('change', handleMotionChange);
        prefersReducedMotion.addListener?.(handleMotionChange);

        window.addEventListener('resize', () => {
          resizeRenderer();
          requestScrollUpdate();
        });
        requestScrollUpdate();
        resizeRenderer();
      } catch (error) {
        root.classList.remove('has-webgl');
        root.classList.add('no-webgl');
        console.error('Failed to start Three.js scene:', error);
      }
    }
  </script>

</body>
</html>
