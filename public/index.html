<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Adam Shanti — Engineering Portfolio</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Engineering projects, experiments, and tools by Adam Shanti." />
  <link rel="icon" href="/favicon.ico" />
  <link rel="stylesheet" href="/publish/style.css" />
</head>
<body>
  <header class="site-header">
    <div class="container">
      <a class="site-logo" href="/">Adam Shanti</a>
      <nav class="site-nav">
        <a href="#projects">Projects</a>
        <a href="#about">About</a>
        <a href="#contact">Contact</a>
        <a class="btn btn-small" href="/Adam_Shanti_Resume.pdf" target="_blank" rel="noopener">Resume</a>
      </nav>
    </div>
  </header>

  <section class="scene-wrap" id="top">
    <canvas id="scene-canvas" aria-hidden="true"></canvas>

    <div class="bg-title" aria-hidden="true">
      <span>crafted for</span>
      <span>aerial excellence</span>
    </div>

    <div class="center-hub">
      <p class="eyebrow">Aerospace Engineer · Builder</p>
      <h1>Adam Shanti</h1>
      <p class="hub-tagline">Rapid prototyping, propulsion test, and mission-scale simulation stitched into one flight-ready toolkit.</p>
      <div class="hub-actions">
        <a class="btn" href="/Adam_Shanti_Resume.pdf" target="_blank" rel="noopener">Resume</a>
        <a class="btn btn-ghost" href="mailto:adam@adamshanti.com">Email</a>
        <a class="btn btn-ghost" href="https://www.linkedin.com/in/..." target="_blank" rel="noopener">LinkedIn</a>
      </div>
      <span class="hint">Move your cursor to orbit · Scroll for details</span>
    </div>

    <div class="island-labels">
      <a class="island-label" style="--x: 21%; --y: 38%;" href="/projects/mk4.html">Mk4 Modular UAV</a>
      <a class="island-label" style="--x: 78%; --y: 42%;" href="/projects/turbojet.html">Turbojet Test Stand</a>
      <a class="island-label" style="--x: 50%; --y: 66%;" href="/projects/mission-sim.html">Mission Profile Simulator</a>
    </div>
  </section>

  <main>
    <section id="projects" class="section section-projects">
      <div class="container">
        <div class="section-heading">
          <div>
            <p class="eyebrow">Featured work</p>
            <h2>Projects</h2>
          </div>
          <label class="tag-controls">
            <span>Filter</span>
            <select id="tagFilter" aria-label="Filter projects by tag">
              <option value="all">All</option>
              <option value="aero">Aero</option>
              <option value="propulsion">Propulsion</option>
              <option value="software">Software</option>
              <option value="hardware">Hardware</option>
              <option value="analysis">Analysis</option>
              <option value="controls">Controls</option>
              <option value="design">Design</option>
              <option value="testing">Testing</option>
            </select>
          </label>
        </div>

        <div class="project-grid">
          <article class="card" data-tags="aero design analysis">
            <img src="/images/mk4-thumb.jpg" alt="Mk4 modular UAV thumbnail" loading="lazy" />
            <div class="card-body">
              <h3 class="card-title">Mk4 Modular UAV</h3>
              <p class="card-text">Modular, 3D-printed fixed-wing UAV with supercapacitor power, rib-and-spar wing, and rapid field repair.</p>
              <ul class="tags">
                <li>aero</li><li>design</li><li>analysis</li>
              </ul>
              <div class="card-actions">
                <a class="btn" href="/projects/mk4.html">Case Study</a>
                <a class="btn btn-ghost" href="https://github.com/..." target="_blank" rel="noopener">Code</a>
              </div>
            </div>
          </article>

          <article class="card" data-tags="propulsion testing hardware">
            <img src="/images/engine-test-thumb.jpg" alt="Engine test stand thumbnail" loading="lazy" />
            <div class="card-body">
              <h3 class="card-title">Turbojet Test Stand</h3>
              <p class="card-text">Instrumented test stand with DAQ, safety interlocks, and calibrated thrust measurement for turbojet characterization.</p>
              <ul class="tags">
                <li>propulsion</li><li>testing</li><li>hardware</li>
              </ul>
              <div class="card-actions">
                <a class="btn" href="/projects/turbojet.html">Case Study</a>
                <a class="btn btn-ghost" href="https://youtu.be/..." target="_blank" rel="noopener">Demo</a>
              </div>
            </div>
          </article>

          <article class="card" data-tags="software analysis controls">
            <img src="/images/mission-sim-thumb.jpg" alt="Mission simulation plot thumbnail" loading="lazy" />
            <div class="card-body">
              <h3 class="card-title">Mission Profile Simulator</h3>
              <p class="card-text">Segment-based aircraft mission sim with carpet plots for TSL vs WTOS and fuel split visualizations.</p>
              <ul class="tags">
                <li>software</li><li>analysis</li><li>controls</li>
              </ul>
              <div class="card-actions">
                <a class="btn" href="/projects/mission-sim.html">Case Study</a>
                <a class="btn btn-ghost" href="https://github.com/..." target="_blank" rel="noopener">Repo</a>
              </div>
            </div>
          </article>
        </div>
      </div>
    </section>

    <section id="about" class="section section-about">
      <div class="container">
        <p class="eyebrow">Who I am</p>
        <h2>About</h2>
        <p class="lede">I’m an aerospace engineer focused on propulsion test, conceptual aircraft design, and simulation. I build tooling and rigs that bridge the gap between first sketch and flight-ready data.</p>
        <div class="about-grid">
          <div>
            <h3>Strengths</h3>
            <ul>
              <li>Full-stack prototyping across CAD, firmware, and cloud orchestration.</li>
              <li>High-fidelity test design with instrumentation, sensor fusion, and safety interlocks.</li>
              <li>Mission analysis and controls modeling for multi-segment flight envelopes.</li>
            </ul>
          </div>
          <div>
            <h3>Currently</h3>
            <ul>
              <li>Building flight-worthy infrastructure that scales from lab rigs to high-altitude operations.</li>
              <li>Exploring reusable airframes and rapid repair workflows for field teams.</li>
              <li>Experimenting with virtual mission rehearsal for distributed pilots.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <section id="contact" class="section section-contact">
      <div class="container">
        <p class="eyebrow">Let’s collaborate</p>
        <h2>Contact</h2>
        <p class="lede">Reach out for propulsion test campaigns, mission tooling, or to collaborate on aerial systems.</p>
        <div class="contact-actions">
          <a class="btn" href="mailto:adam@adamshanti.com">adam@adamshanti.com</a>
          <a class="btn btn-ghost" href="https://www.linkedin.com/in/..." target="_blank" rel="noopener">LinkedIn</a>
        </div>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="container">
      <small>© <span id="year"></span> Adam Shanti · Built for the cloud edge</small>
    </div>
  </footer>

  <script>
    document.getElementById('year').textContent = new Date().getFullYear();
    const select = document.getElementById('tagFilter');
    const cards = Array.from(document.querySelectorAll('.project-grid .card'));
    if (select) {
      select.addEventListener('change', () => {
        const tag = select.value;
        cards.forEach(card => {
          const tags = (card.getAttribute('data-tags') || '').split(/\s+/);
          const show = tag === 'all' || tags.includes(tag);
          card.style.display = show ? '' : 'none';
        });
      });
    }
  </script>

  <script type="module">
    const root = document.documentElement;
    const sceneWrap = document.querySelector('.scene-wrap');
    const canvas = document.getElementById('scene-canvas');
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)');

    function hasWebGL() {
      try {
        const testCanvas = document.createElement('canvas');
        return !!window.WebGLRenderingContext && !!(testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl'));
      } catch (err) {
        return false;
      }
    }

    if (!hasWebGL()) {
      root.classList.add('no-webgl');
      console.warn('WebGL not available; keeping fallback labels visible.');
    } else {
      root.classList.add('has-webgl');
      try {
        const THREE = await import('https://cdn.jsdelivr.net/npm/three@0.156.1/build/three.module.js');

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.outputColorSpace = THREE.SRGBColorSpace;

        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x070e1f, 14, 48);

        const camera = new THREE.PerspectiveCamera(50, canvas.clientWidth / canvas.clientHeight, 0.1, 120);
        camera.position.set(0, 3.4, 9.8);

        const ambient = new THREE.AmbientLight(0xe7f2ff, 0.55);
        scene.add(ambient);

        const keyLight = new THREE.DirectionalLight(0xfff3d1, 1.9);
        keyLight.position.set(6, 8, 6);
        scene.add(keyLight);

        const rimLight = new THREE.DirectionalLight(0x84b9ff, 1.4);
        rimLight.position.set(-6, 4, -5);
        scene.add(rimLight);

        const topLight = new THREE.SpotLight(0xb3e8ff, 1.1, 40, Math.PI / 4.2, 0.6, 1.5);
        topLight.position.set(0, 7, 2);
        topLight.target.position.set(0, 0, 0);
        scene.add(topLight, topLight.target);

        const stage = new THREE.Group();
        stage.position.y = -0.8;
        scene.add(stage);

        const gradientBacker = new THREE.Mesh(
          new THREE.PlaneGeometry(30, 16),
          new THREE.MeshBasicMaterial({ color: 0x192c54, transparent: true, opacity: 0.58 })
        );
        gradientBacker.position.set(0, 3, -12);
        scene.add(gradientBacker);

        const groundGlow = new THREE.Mesh(
          new THREE.CircleGeometry(11, 96),
          new THREE.MeshBasicMaterial({ color: 0x133063, transparent: true, opacity: 0.48 })
        );
        groundGlow.rotation.x = -Math.PI / 2;
        groundGlow.position.y = -1.7;
        stage.add(groundGlow);

        const auraRing = new THREE.Mesh(
          new THREE.RingGeometry(6.2, 7.1, 64),
          new THREE.MeshBasicMaterial({ color: 0x68d8ff, transparent: true, opacity: 0.32, side: THREE.DoubleSide })
        );
        auraRing.rotation.x = -Math.PI / 2;
        auraRing.position.y = -0.35;
        stage.add(auraRing);

        const floatingItems = [];
        const registerFloat = (group, amplitude = 0.2, speed = 1, spin = 0) => {
          floatingItems.push({
            group,
            baseY: group.position.y,
            amplitude,
            speed,
            offset: Math.random() * Math.PI * 2,
            spin
          });
        };

        const buildHeroPlatform = () => {
          const group = new THREE.Group();

          const base = new THREE.Mesh(
            new THREE.CylinderGeometry(8.4, 8.9, 0.8, 80),
            new THREE.MeshStandardMaterial({ color: 0x152543, metalness: 0.3, roughness: 0.85 })
          );
          base.position.y = -0.45;
          group.add(base);

          const mid = new THREE.Mesh(
            new THREE.CylinderGeometry(6.4, 6.8, 0.6, 64),
            new THREE.MeshStandardMaterial({ color: 0x233e76, metalness: 0.35, roughness: 0.72 })
          );
          mid.position.y = -0.05;
          group.add(mid);

          const top = new THREE.Mesh(
            new THREE.CylinderGeometry(4.8, 5.1, 0.4, 48),
            new THREE.MeshStandardMaterial({ color: 0x3f5ed0, metalness: 0.45, roughness: 0.46, emissive: 0x132d7a, emissiveIntensity: 0.22 })
          );
          top.position.y = 0.45;
          group.add(top);

          const runway = new THREE.Mesh(
            new THREE.BoxGeometry(7.2, 0.22, 3.4),
            new THREE.MeshStandardMaterial({ color: 0x3455c6, metalness: 0.32, roughness: 0.52 })
          );
          runway.position.set(0, 0.85, 1.35);
          runway.rotation.y = -0.12;
          group.add(runway);

          const accent = new THREE.Mesh(
            new THREE.TorusGeometry(5.7, 0.08, 36, 140),
            new THREE.MeshBasicMaterial({ color: 0x7ce3ff, transparent: true, opacity: 0.38 })
          );
          accent.rotation.x = Math.PI / 2;
          accent.position.y = 0.4;
          group.add(accent);

          return group;
        };

        const buildArchCluster = () => {
          const group = new THREE.Group();

          const base = new THREE.Mesh(
            new THREE.CylinderGeometry(1.6, 1.9, 0.32, 32),
            new THREE.MeshStandardMaterial({ color: 0x6959f0, metalness: 0.3, roughness: 0.6 })
          );
          base.position.y = 0.16;
          group.add(base);

          const arch = new THREE.Mesh(
            new THREE.TorusGeometry(1.1, 0.18, 32, 120, Math.PI),
            new THREE.MeshStandardMaterial({ color: 0x7f8cff, metalness: 0.25, roughness: 0.45 })
          );
          arch.rotation.z = Math.PI;
          arch.rotation.x = Math.PI / 2;
          arch.position.y = 1.2;
          group.add(arch);

          const pillarL = new THREE.Mesh(
            new THREE.BoxGeometry(0.24, 2.1, 0.6),
            new THREE.MeshStandardMaterial({ color: 0x7586ff, metalness: 0.2, roughness: 0.4 })
          );
          pillarL.position.set(-0.6, 1, 0);
          group.add(pillarL);

          const pillarR = pillarL.clone();
          pillarR.position.x = 0.6;
          group.add(pillarR);

          const cushion = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.55, 0.8, 10, 20),
            new THREE.MeshStandardMaterial({ color: 0xffb48f, roughness: 0.55, metalness: 0.1 })
          );
          cushion.rotation.z = Math.PI / 2;
          cushion.position.set(0, 0.55, 0.28);
          group.add(cushion);

          const laptopBase = new THREE.Mesh(
            new THREE.BoxGeometry(0.9, 0.08, 0.55),
            new THREE.MeshStandardMaterial({ color: 0x222c4b, roughness: 0.2, metalness: 0.6 })
          );
          laptopBase.position.set(0.1, 1.0, 0.2);
          laptopBase.rotation.y = 0.2;
          laptopBase.rotation.x = -0.05;
          group.add(laptopBase);

          const laptopScreen = new THREE.Mesh(
            new THREE.BoxGeometry(0.86, 0.54, 0.05),
            new THREE.MeshStandardMaterial({ color: 0x9fd8ff, emissive: 0x5ac8ff, emissiveIntensity: 0.6 })
          );
          laptopScreen.position.set(0.12, 1.25, -0.02);
          laptopScreen.rotation.x = Math.PI / 2.3;
          laptopScreen.rotation.y = 0.2;
          group.add(laptopScreen);

          const hangingStem = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.08, 1.6, 12),
            new THREE.MeshStandardMaterial({ color: 0x4bbf8f, metalness: 0.2, roughness: 0.6 })
          );
          hangingStem.position.set(-0.62, 1.4, 0.12);
          group.add(hangingStem);

          const hangingLeaves = new THREE.Mesh(
            new THREE.ConeGeometry(0.3, 0.9, 24, 1, true),
            new THREE.MeshStandardMaterial({ color: 0x7cfcc0, transparent: true, opacity: 0.7, side: THREE.DoubleSide })
          );
          hangingLeaves.position.set(-0.62, 0.7, 0.12);
          group.add(hangingLeaves);

          return group;
        };

        const buildHeroSign = () => {
          const group = new THREE.Group();

          const pedestal = new THREE.Mesh(
            new THREE.BoxGeometry(1.4, 0.4, 2),
            new THREE.MeshStandardMaterial({ color: 0x384c92, metalness: 0.28, roughness: 0.55 })
          );
          pedestal.position.set(0, 0.2, -0.35);
          group.add(pedestal);

          const frame = new THREE.Mesh(
            new THREE.PlaneGeometry(4.2, 2.6),
            new THREE.MeshStandardMaterial({ color: 0xe8e6ff, metalness: 0.08, roughness: 0.92 })
          );
          frame.position.set(0, 1.8, -1);
          frame.rotation.y = 0.38;
          group.add(frame);

          const glowPanel = new THREE.Mesh(
            new THREE.PlaneGeometry(3.1, 1.4),
            new THREE.MeshBasicMaterial({ color: 0x8fd3ff, transparent: true, opacity: 0.5 })
          );
          glowPanel.position.set(0.16, 1.86, -0.9);
          glowPanel.rotation.y = 0.38;
          group.add(glowPanel);

          const badge = new THREE.Mesh(
            new THREE.TorusGeometry(0.34, 0.07, 20, 80),
            new THREE.MeshStandardMaterial({ color: 0xffad74, metalness: 0.4, roughness: 0.35 })
          );
          badge.position.set(-1.4, 1.05, -0.5);
          badge.rotation.y = 0.38;
          group.add(badge);

          const badgeOrb = new THREE.Mesh(
            new THREE.SphereGeometry(0.22, 24, 24),
            new THREE.MeshStandardMaterial({ color: 0xffd8c0, emissive: 0xffb46f, emissiveIntensity: 0.3 })
          );
          badgeOrb.position.set(-1.4, 1.05, -0.5);
          group.add(badgeOrb);

          return group;
        };

        const buildUavModule = () => {
          const group = new THREE.Group();

          const base = new THREE.Mesh(
            new THREE.CylinderGeometry(1.8, 2.1, 0.32, 36),
            new THREE.MeshStandardMaterial({ color: 0x283c88, metalness: 0.35, roughness: 0.6 })
          );
          base.position.y = 0.16;
          group.add(base);

          const pad = new THREE.Mesh(
            new THREE.CylinderGeometry(1.6, 1.7, 0.18, 36),
            new THREE.MeshStandardMaterial({ color: 0x4964f5, metalness: 0.45, roughness: 0.4 })
          );
          pad.position.y = 0.35;
          group.add(pad);

          const fuselage = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.4, 1.2, 12, 24),
            new THREE.MeshStandardMaterial({ color: 0xbbe1ff, metalness: 0.55, roughness: 0.25 })
          );
          fuselage.rotation.z = Math.PI / 2;
          fuselage.position.set(0, 0.75, 0);
          group.add(fuselage);

          const wing = new THREE.Mesh(
            new THREE.BoxGeometry(2.4, 0.16, 0.42),
            new THREE.MeshStandardMaterial({ color: 0x9adbff, metalness: 0.5, roughness: 0.24 })
          );
          wing.position.y = 0.92;
          group.add(wing);

          const tail = new THREE.Mesh(
            new THREE.BoxGeometry(0.65, 0.45, 0.12),
            new THREE.MeshStandardMaterial({ color: 0x84c7ff, metalness: 0.5, roughness: 0.3 })
          );
          tail.position.set(-0.8, 1.05, 0);
          tail.rotation.z = 0.3;
          group.add(tail);

          const sensorPod = new THREE.Mesh(
            new THREE.CylinderGeometry(0.15, 0.15, 0.4, 24),
            new THREE.MeshStandardMaterial({ color: 0xffc48f, metalness: 0.4, roughness: 0.35 })
          );
          sensorPod.rotation.x = Math.PI / 2;
          sensorPod.position.set(0.85, 0.65, 0);
          group.add(sensorPod);

          const halo = new THREE.Mesh(
            new THREE.RingGeometry(1.2, 1.38, 64),
            new THREE.MeshBasicMaterial({ color: 0x63d8ff, transparent: true, opacity: 0.32, side: THREE.DoubleSide })
          );
          halo.rotation.x = Math.PI / 2;
          halo.position.y = 0.46;
          group.add(halo);

          return group;
        };

        const buildTestStandModule = () => {
          const group = new THREE.Group();

          const base = new THREE.Mesh(
            new THREE.CylinderGeometry(2.1, 2.4, 0.34, 40),
            new THREE.MeshStandardMaterial({ color: 0x7c468d, metalness: 0.4, roughness: 0.58 })
          );
          base.position.y = 0.17;
          group.add(base);

          const pad = new THREE.Mesh(
            new THREE.CylinderGeometry(1.9, 2, 0.22, 40),
            new THREE.MeshStandardMaterial({ color: 0xb777d8, metalness: 0.4, roughness: 0.35 })
          );
          pad.position.y = 0.48;
          group.add(pad);

          const column = new THREE.Mesh(
            new THREE.BoxGeometry(0.38, 1.9, 0.38),
            new THREE.MeshStandardMaterial({ color: 0xf5c27a, metalness: 0.35, roughness: 0.45 })
          );
          column.position.set(0.6, 1.2, 0);
          group.add(column);

          const engine = new THREE.Mesh(
            new THREE.ConeGeometry(0.55, 1.1, 28, 1, true),
            new THREE.MeshStandardMaterial({ color: 0x37394f, roughness: 0.4, metalness: 0.75, side: THREE.DoubleSide })
          );
          engine.rotation.x = Math.PI / 2;
          engine.position.set(-0.1, 1.12, 0);
          group.add(engine);

          const nozzle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.28, 0.45, 0.3, 24),
            new THREE.MeshStandardMaterial({ color: 0x4d76ff, metalness: 0.6, roughness: 0.3 })
          );
          nozzle.rotation.x = Math.PI / 2;
          nozzle.position.set(-0.68, 1.12, 0);
          group.add(nozzle);

          const thrustPlate = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, 1.6, 1.4),
            new THREE.MeshStandardMaterial({ color: 0x42486a, metalness: 0.45, roughness: 0.32 })
          );
          thrustPlate.position.set(-0.38, 1.12, 0);
          group.add(thrustPlate);

          const sensorSphere = new THREE.Mesh(
            new THREE.SphereGeometry(0.28, 22, 22),
            new THREE.MeshStandardMaterial({ color: 0xffe8bc, emissive: 0xffb057, emissiveIntensity: 0.25 })
          );
          sensorSphere.position.set(0.76, 1.82, 0.46);
          group.add(sensorSphere);

          const cable = new THREE.Mesh(
            new THREE.TorusGeometry(1.05, 0.04, 12, 90, Math.PI / 1.3),
            new THREE.MeshStandardMaterial({ color: 0x2c2f3f, metalness: 0.3, roughness: 0.6 })
          );
          cable.position.set(0.3, 0.85, 0);
          cable.rotation.z = -Math.PI / 2.2;
          group.add(cable);

          return group;
        };

        const buildMissionModule = () => {
          const group = new THREE.Group();

          const base = new THREE.Mesh(
            new THREE.CylinderGeometry(2.2, 2.4, 0.32, 40),
            new THREE.MeshStandardMaterial({ color: 0x2a6a75, metalness: 0.38, roughness: 0.55 })
          );
          base.position.y = 0.16;
          group.add(base);

          const sand = new THREE.Mesh(
            new THREE.CylinderGeometry(2, 2.1, 0.2, 40),
            new THREE.MeshStandardMaterial({ color: 0x74d5d8, metalness: 0.25, roughness: 0.35 })
          );
          sand.position.y = 0.44;
          group.add(sand);

          const table = new THREE.Mesh(
            new THREE.BoxGeometry(2.4, 0.12, 1.1),
            new THREE.MeshStandardMaterial({ color: 0xcfd4ff, metalness: 0.3, roughness: 0.4 })
          );
          table.position.set(0, 1.05, 0);
          table.rotation.y = -0.35;
          group.add(table);

          const leg1 = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08, 0.08, 0.8, 12),
            new THREE.MeshStandardMaterial({ color: 0xf1b788, metalness: 0.3, roughness: 0.6 })
          );
          leg1.position.set(0.88, 0.7, 0.42);
          leg1.rotation.x = Math.PI / 2;
          leg1.rotation.z = Math.PI / 2;
          group.add(leg1);
          const leg2 = leg1.clone();
          leg2.position.set(-0.88, 0.7, -0.42);
          group.add(leg2);
          const leg3 = leg1.clone();
          leg3.position.set(0.88, 0.7, -0.42);
          group.add(leg3);
          const leg4 = leg1.clone();
          leg4.position.set(-0.88, 0.7, 0.42);
          group.add(leg4);

          const display = new THREE.Mesh(
            new THREE.PlaneGeometry(1.8, 1.1),
            new THREE.MeshStandardMaterial({ color: 0x9ad9ff, emissive: 0x4acaff, emissiveIntensity: 0.55, transparent: true, opacity: 0.92 })
          );
          display.position.set(0, 1.62, -0.18);
          display.rotation.x = -Math.PI / 9;
          display.rotation.y = -0.3;
          group.add(display);

          const chart = new THREE.Mesh(
            new THREE.PlaneGeometry(1.2, 0.72),
            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.35 })
          );
          chart.position.set(-0.06, 1.58, -0.26);
          chart.rotation.x = -Math.PI / 9;
          chart.rotation.y = -0.3;
          group.add(chart);

          const orb = new THREE.Mesh(
            new THREE.SphereGeometry(0.38, 24, 24),
            new THREE.MeshStandardMaterial({ color: 0xff96cf, emissive: 0xff61b9, emissiveIntensity: 0.3 })
          );
          orb.position.set(0.98, 1.34, 0.48);
          group.add(orb);

          const plantPot = new THREE.Mesh(
            new THREE.CylinderGeometry(0.32, 0.46, 0.4, 24),
            new THREE.MeshStandardMaterial({ color: 0xb58d54, metalness: 0.2, roughness: 0.6 })
          );
          plantPot.position.set(-1.05, 0.75, 0.55);
          group.add(plantPot);

          const plantLeaves = new THREE.Mesh(
            new THREE.ConeGeometry(0.55, 1, 18, 1, true),
            new THREE.MeshStandardMaterial({ color: 0x74ffbf, transparent: true, opacity: 0.75, side: THREE.DoubleSide })
          );
          plantLeaves.position.set(-1.05, 1.3, 0.55);
          group.add(plantLeaves);

          return group;
        };

        stage.add(buildHeroPlatform());

        const archCluster = buildArchCluster();
        archCluster.position.set(-0.2, 0.1, -0.4);
        stage.add(archCluster);
        registerFloat(archCluster, 0.12, 0.9, 0.001);

        const heroSign = buildHeroSign();
        heroSign.position.set(1.4, 0.6, -0.4);
        stage.add(heroSign);
        registerFloat(heroSign, 0.1, 0.8, 0.0006);

        const uavModule = buildUavModule();
        uavModule.position.set(-3.2, 0.35, -1.9);
        stage.add(uavModule);
        registerFloat(uavModule, 0.24, 1.15, 0.002);

        const testModule = buildTestStandModule();
        testModule.position.set(3.1, 0.42, -1.4);
        stage.add(testModule);
        registerFloat(testModule, 0.22, 0.95, -0.0016);

        const missionModule = buildMissionModule();
        missionModule.position.set(0.6, 0.7, 2.5);
        stage.add(missionModule);
        registerFloat(missionModule, 0.28, 0.85, 0.0012);

        const beacon = new THREE.Mesh(
          new THREE.SphereGeometry(0.42, 24, 24),
          new THREE.MeshStandardMaterial({ color: 0x63d8ff, emissive: 0x2cd4ff, emissiveIntensity: 0.6 })
        );
        beacon.position.set(-1.45, 1.68, 1.8);
        stage.add(beacon);
        registerFloat(beacon, 0.35, 1.5, 0.004);

        const beaconHalo = new THREE.Mesh(
          new THREE.RingGeometry(0.45, 0.65, 64),
          new THREE.MeshBasicMaterial({ color: 0x83f4ff, transparent: true, opacity: 0.45 })
        );
        beaconHalo.rotation.x = Math.PI / 2;
        beaconHalo.position.copy(beacon.position);
        stage.add(beaconHalo);

        const probe = new THREE.Mesh(
          new THREE.CapsuleGeometry(0.18, 0.8, 8, 16),
          new THREE.MeshStandardMaterial({ color: 0xffe69c, metalness: 0.4, roughness: 0.3 })
        );
        probe.rotation.z = -0.6;
        probe.position.set(2.1, 1.4, 1.8);
        stage.add(probe);
        registerFloat(probe, 0.2, 1.4, 0.003);

        const probeRing = new THREE.Mesh(
          new THREE.TorusGeometry(0.34, 0.05, 18, 70),
          new THREE.MeshStandardMaterial({ color: 0xffae6a, metalness: 0.5, roughness: 0.4 })
        );
        probeRing.rotation.x = Math.PI / 2;
        probeRing.position.set(2.1, 1.02, 1.8);
        stage.add(probeRing);

        const starCount = 720;
        const starGeometry = new THREE.BufferGeometry();
        const starPositions = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount; i += 1) {
          starPositions[i * 3] = (Math.random() - 0.5) * 60;
          starPositions[i * 3 + 1] = Math.random() * 28 + 4;
          starPositions[i * 3 + 2] = (Math.random() - 0.5) * 60;
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0x68b7ff, size: 0.08, transparent: true, opacity: 0.55, depthWrite: false });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        const pointer = { x: 0, y: 0 };
        const pointerTarget = { x: 0, y: 0 };
        let idleTimer = 0;

        const updatePointer = event => {
          const rect = sceneWrap.getBoundingClientRect();
          pointerTarget.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          pointerTarget.y = ((event.clientY - rect.top) / rect.height) * 2 - 1;
          idleTimer = 0;
        };

        sceneWrap.addEventListener('pointermove', updatePointer);
        sceneWrap.addEventListener('pointerdown', updatePointer);
        sceneWrap.addEventListener('pointerleave', () => {
          pointerTarget.x = 0;
          pointerTarget.y = 0;
        });

        const clock = new THREE.Clock();

        function resizeRenderer() {
          const pixelRatio = Math.min(window.devicePixelRatio, 2);
          const width = canvas.clientWidth;
          const height = canvas.clientHeight;
          if (canvas.width !== Math.floor(width * pixelRatio) || canvas.height !== Math.floor(height * pixelRatio)) {
            renderer.setSize(width, height, false);
            renderer.setPixelRatio(pixelRatio);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
          }
        }

        function render() {
          resizeRenderer();
          const delta = clock.getDelta();
          const elapsed = clock.getElapsedTime();
          idleTimer += delta;

          if (!prefersReducedMotion.matches) {
            if (idleTimer > 6) {
              pointerTarget.x = Math.sin(elapsed * 0.25) * 0.35;
              pointerTarget.y = Math.cos(elapsed * 0.2) * 0.18;
            }

            pointer.x += (pointerTarget.x - pointer.x) * 0.08;
            pointer.y += (pointerTarget.y - pointer.y) * 0.08;

            const targetY = pointer.x * 0.55;
            const targetX = THREE.MathUtils.clamp(pointer.y * 0.22, -0.2, 0.24);
            stage.rotation.y += (targetY - stage.rotation.y) * 0.05;
            stage.rotation.x += (targetX - stage.rotation.x) * 0.05;

            floatingItems.forEach(item => {
              const bob = Math.sin(elapsed * item.speed + item.offset) * item.amplitude;
              item.group.position.y = item.baseY + bob;
              if (item.spin) {
                item.group.rotation.y += item.spin;
              }
            });

            auraRing.scale.setScalar(1 + Math.sin(elapsed * 0.4) * 0.04);
            beaconHalo.rotation.z += 0.01;
            probeRing.rotation.y += 0.01;
            stars.rotation.y -= 0.0003;
          } else {
            stage.rotation.x += (0 - stage.rotation.x) * 0.08;
            stage.rotation.y += (0 - stage.rotation.y) * 0.08;
          }

          renderer.render(scene, camera);
        }

        renderer.setAnimationLoop(render);

        const handleMotionChange = () => {
          if (prefersReducedMotion.matches) {
            floatingItems.forEach(item => {
              item.group.position.y = item.baseY;
            });
            pointerTarget.x = 0;
            pointerTarget.y = 0;
          }
        };

        prefersReducedMotion.addEventListener?.('change', handleMotionChange);
        prefersReducedMotion.addListener?.(handleMotionChange);

        window.addEventListener('resize', resizeRenderer);
        resizeRenderer();
      } catch (error) {
        root.classList.remove('has-webgl');
        root.classList.add('no-webgl');
        console.error('Failed to start Three.js scene:', error);
      }
    }
  </script>
</body>
</html>
