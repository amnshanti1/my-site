<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Adam Shanti — Engineering Portfolio</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Engineering projects, experiments, and tools by Adam Shanti." />
  <link rel="icon" href="/favicon.ico" />
  <link rel="stylesheet" href="/publish/style.css" />
</head>
<body>
  <header class="site-header">
    <div class="container">
      <a class="site-logo" href="/">Adam Shanti</a>
      <nav class="site-nav">
        <a href="#projects">Projects</a>
        <a href="#about">About</a>
        <a href="#contact">Contact</a>
        <a class="btn btn-small" href="/Adam_Shanti_Resume.pdf" target="_blank" rel="noopener">Resume</a>
      </nav>
    </div>
  </header>

  <section class="scene-wrap" id="top">
    <canvas id="scene-canvas" aria-hidden="true"></canvas>

    <div class="bg-title" aria-hidden="true">
      <span>crafted for</span>
      <span>aerial excellence</span>
    </div>

    <div class="center-hub">
      <p class="eyebrow">Aerospace Engineer · Builder</p>
      <h1>Adam Shanti</h1>
      <p class="hub-tagline">Rapid prototyping, propulsion test, and mission-scale simulation stitched into one flight-ready toolkit.</p>
      <div class="hub-actions">
        <a class="btn" href="/Adam_Shanti_Resume.pdf" target="_blank" rel="noopener">Resume</a>
        <a class="btn btn-ghost" href="mailto:adam@adamshanti.com">Email</a>
        <a class="btn btn-ghost" href="https://www.linkedin.com/in/..." target="_blank" rel="noopener">LinkedIn</a>
      </div>
      <span class="hint">Move your cursor to orbit · Scroll for details</span>
    </div>

    <div class="island-labels">
      <a class="island-label" style="--x: 50%; --y: 46%;" href="/Adam_Shanti_Resume.pdf" target="_blank" rel="noopener">Resume Hub</a>
      <a class="island-label" style="--x: 24%; --y: 34%;" href="/projects/interceptor.html">Senior Design Interceptor</a>
      <a class="island-label" style="--x: 78%; --y: 36%;" href="/projects/mk4.html">Mk4 Drone Platform</a>
      <a class="island-label" style="--x: 56%; --y: 70%;" href="/projects/leading-edge.html">Leading Edge Extension</a>
    </div>
  </section>

  <main>
    <section id="projects" class="section section-projects">
      <div class="container">
        <div class="section-heading">
          <div>
            <p class="eyebrow">Featured work</p>
            <h2>Projects</h2>
          </div>
          <label class="tag-controls">
            <span>Filter</span>
            <select id="tagFilter" aria-label="Filter projects by tag">
              <option value="all">All</option>
              <option value="aero">Aero</option>
              <option value="propulsion">Propulsion</option>
              <option value="software">Software</option>
              <option value="hardware">Hardware</option>
              <option value="analysis">Analysis</option>
              <option value="controls">Controls</option>
              <option value="design">Design</option>
              <option value="testing">Testing</option>
            </select>
          </label>
        </div>

        <div class="project-grid">
          <article class="card" data-tags="aero design analysis">
            <img src="/images/mk4-thumb.jpg" alt="Mk4 modular UAV thumbnail" loading="lazy" />
            <div class="card-body">
              <h3 class="card-title">Mk4 Modular UAV</h3>
              <p class="card-text">Modular, 3D-printed fixed-wing UAV with supercapacitor power, rib-and-spar wing, and rapid field repair.</p>
              <ul class="tags">
                <li>aero</li><li>design</li><li>analysis</li>
              </ul>
              <div class="card-actions">
                <a class="btn" href="/projects/mk4.html">Case Study</a>
                <a class="btn btn-ghost" href="https://github.com/..." target="_blank" rel="noopener">Code</a>
              </div>
            </div>
          </article>

          <article class="card" data-tags="propulsion testing hardware">
            <img src="/images/engine-test-thumb.jpg" alt="Engine test stand thumbnail" loading="lazy" />
            <div class="card-body">
              <h3 class="card-title">Turbojet Test Stand</h3>
              <p class="card-text">Instrumented test stand with DAQ, safety interlocks, and calibrated thrust measurement for turbojet characterization.</p>
              <ul class="tags">
                <li>propulsion</li><li>testing</li><li>hardware</li>
              </ul>
              <div class="card-actions">
                <a class="btn" href="/projects/turbojet.html">Case Study</a>
                <a class="btn btn-ghost" href="https://youtu.be/..." target="_blank" rel="noopener">Demo</a>
              </div>
            </div>
          </article>

          <article class="card" data-tags="software analysis controls">
            <img src="/images/mission-sim-thumb.jpg" alt="Mission simulation plot thumbnail" loading="lazy" />
            <div class="card-body">
              <h3 class="card-title">Mission Profile Simulator</h3>
              <p class="card-text">Segment-based aircraft mission sim with carpet plots for TSL vs WTOS and fuel split visualizations.</p>
              <ul class="tags">
                <li>software</li><li>analysis</li><li>controls</li>
              </ul>
              <div class="card-actions">
                <a class="btn" href="/projects/mission-sim.html">Case Study</a>
                <a class="btn btn-ghost" href="https://github.com/..." target="_blank" rel="noopener">Repo</a>
              </div>
            </div>
          </article>
        </div>
      </div>
    </section>

    <section id="about" class="section section-about">
      <div class="container">
        <p class="eyebrow">Who I am</p>
        <h2>About</h2>
        <p class="lede">I’m an aerospace engineer focused on propulsion test, conceptual aircraft design, and simulation. I build tooling and rigs that bridge the gap between first sketch and flight-ready data.</p>
        <div class="about-grid">
          <div>
            <h3>Strengths</h3>
            <ul>
              <li>Full-stack prototyping across CAD, firmware, and cloud orchestration.</li>
              <li>High-fidelity test design with instrumentation, sensor fusion, and safety interlocks.</li>
              <li>Mission analysis and controls modeling for multi-segment flight envelopes.</li>
            </ul>
          </div>
          <div>
            <h3>Currently</h3>
            <ul>
              <li>Building flight-worthy infrastructure that scales from lab rigs to high-altitude operations.</li>
              <li>Exploring reusable airframes and rapid repair workflows for field teams.</li>
              <li>Experimenting with virtual mission rehearsal for distributed pilots.</li>
            </ul>
          </div>
        </div>
      </div>
    </section>

    <section id="contact" class="section section-contact">
      <div class="container">
        <p class="eyebrow">Let’s collaborate</p>
        <h2>Contact</h2>
        <p class="lede">Reach out for propulsion test campaigns, mission tooling, or to collaborate on aerial systems.</p>
        <div class="contact-actions">
          <a class="btn" href="mailto:adam@adamshanti.com">adam@adamshanti.com</a>
          <a class="btn btn-ghost" href="https://www.linkedin.com/in/..." target="_blank" rel="noopener">LinkedIn</a>
        </div>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="container">
      <small>© <span id="year"></span> Adam Shanti · Built for the cloud edge</small>
    </div>
  </footer>

  <script>
    document.getElementById('year').textContent = new Date().getFullYear();
    const select = document.getElementById('tagFilter');
    const cards = Array.from(document.querySelectorAll('.project-grid .card'));
    if (select) {
      select.addEventListener('change', () => {
        const tag = select.value;
        cards.forEach(card => {
          const tags = (card.getAttribute('data-tags') || '').split(/\s+/);
          const show = tag === 'all' || tags.includes(tag);
          card.style.display = show ? '' : 'none';
        });
      });
    }
  </script>

  
  <script type="module">
    const root = document.documentElement;
    const sceneWrap = document.querySelector('.scene-wrap');
    const canvas = document.getElementById('scene-canvas');
    const centerHubEl = document.querySelector('.center-hub');
    const bgTitleEl = document.querySelector('.bg-title');
    const projectsSection = document.getElementById('projects');
    const headerEl = document.querySelector('.site-header');
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)');

    function hasWebGL() {
      try {
        const testCanvas = document.createElement('canvas');
        return !!window.WebGLRenderingContext && !!(testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl'));
      } catch (err) {
        return false;
      }
    }

    if (!hasWebGL()) {
      root.classList.add('no-webgl');
      console.warn('WebGL not available; keeping fallback labels visible.');
    } else {
      root.classList.add('has-webgl');
      try {
        const THREE = await import('https://cdn.jsdelivr.net/npm/three@0.156.1/build/three.module.js');

        if (projectsSection) {
          projectsSection.style.opacity = '0';
          projectsSection.style.transform = 'translateY(40px)';
          projectsSection.style.willChange = 'opacity, transform';
        }
        if (centerHubEl) {
          centerHubEl.style.willChange = 'opacity, transform';
        }
        if (bgTitleEl) {
          bgTitleEl.style.willChange = 'opacity, transform';
        }

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.outputColorSpace = THREE.SRGBColorSpace;

        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x070e1f, 14, 48);

        const camera = new THREE.PerspectiveCamera(50, canvas.clientWidth / canvas.clientHeight, 0.1, 120);
        camera.position.set(0, 3.4, 9.8);

        const ambient = new THREE.AmbientLight(0xe7f2ff, 0.55);
        scene.add(ambient);

        const keyLight = new THREE.DirectionalLight(0xfff3d1, 1.9);
        keyLight.position.set(6, 8, 6);
        scene.add(keyLight);

        const rimLight = new THREE.DirectionalLight(0x84b9ff, 1.4);
        rimLight.position.set(-6, 4, -5);
        scene.add(rimLight);

        const topLight = new THREE.SpotLight(0xb3e8ff, 1.1, 40, Math.PI / 4.2, 0.6, 1.5);
        topLight.position.set(0, 7, 2);
        topLight.target.position.set(0, 0, 0);
        scene.add(topLight, topLight.target);

        const stage = new THREE.Group();
        stage.position.y = 0.45;
        scene.add(stage);

        const stageBasePosition = stage.position.clone();
        const stageBaseScale = stage.scale.x;
        const easeInOut = t => t * t * (3 - 2 * t);
        let scrollProgress = 0;
        let scrollProgressTarget = 0;
        let scrollNeedsUpdate = true;
        const headerHeight = headerEl ? headerEl.offsetHeight : 0;

        const updateScrollTarget = () => {
          const rect = sceneWrap.getBoundingClientRect();
          const total = Math.max(sceneWrap.offsetHeight - window.innerHeight * 0.6, 1);
          const distance = THREE.MathUtils.clamp(headerHeight - rect.top, 0, total);
          scrollProgressTarget = distance / total;
        };

        const requestScrollUpdate = () => { scrollNeedsUpdate = true; };
        window.addEventListener('scroll', requestScrollUpdate, { passive: true });

        const gradientBacker = new THREE.Mesh(
          new THREE.PlaneGeometry(30, 16),
          new THREE.MeshBasicMaterial({ color: 0x1a2f56, transparent: true, opacity: 0.6 })
        );
        gradientBacker.position.set(0, 3, -12);
        scene.add(gradientBacker);

        const groundGlow = new THREE.Mesh(
          new THREE.CircleGeometry(11.5, 96),
          new THREE.MeshBasicMaterial({ color: 0x133063, transparent: true, opacity: 0.48 })
        );
        groundGlow.rotation.x = -Math.PI / 2;
        groundGlow.position.y = -1.7;
        stage.add(groundGlow);

        const auraRing = new THREE.Mesh(
          new THREE.RingGeometry(6.6, 7.6, 64),
          new THREE.MeshBasicMaterial({ color: 0x68d8ff, transparent: true, opacity: 0.32, side: THREE.DoubleSide })
        );
        auraRing.rotation.x = -Math.PI / 2;
        auraRing.position.y = -0.25;
        stage.add(auraRing);

        const floatingItems = [];
        const registerFloat = (group, amplitude = 0.2, speed = 1, spin = 0) => {
          floatingItems.push({
            group,
            baseY: group.position.y,
            amplitude,
            speed,
            offset: Math.random() * Math.PI * 2,
            spin
          });
        };

        const heroExplodePieces = [];
        const registerHeroPiece = (mesh, { offset = new THREE.Vector3(), rotation = new THREE.Euler(), scale = 0 } = {}) => {
          heroExplodePieces.push({
            mesh,
            basePosition: mesh.position.clone(),
            baseRotation: mesh.rotation.clone(),
            baseScale: mesh.scale.clone(),
            offset,
            rotation,
            scale
          });
        };

        const interactives = [];
        const interactiveMeshes = [];
        const registerInteractive = (mesh, config) => {
          mesh.userData.interactive = config;
          interactiveMeshes.push(mesh);
          interactives.push(config);
        };

        const heroBadgeMaterial = new THREE.MeshStandardMaterial({
          color: 0xffd479,
          emissive: 0xffb13a,
          emissiveIntensity: 0.45,
          metalness: 0.3,
          roughness: 0.5
        });

        const buildHeroShowcase = () => {
          const group = new THREE.Group();

          const baseLower = new THREE.Mesh(
            new THREE.CylinderGeometry(5.8, 6.3, 0.7, 100),
            new THREE.MeshStandardMaterial({ color: 0x202f58, metalness: 0.32, roughness: 0.78 })
          );
          baseLower.position.set(0, 0, 0);
          baseLower.position.y = 0.05;
          group.add(baseLower);

          const baseMid = new THREE.Mesh(
            new THREE.CylinderGeometry(4.6, 5.2, 0.55, 80),
            new THREE.MeshStandardMaterial({ color: 0x2b448a, metalness: 0.38, roughness: 0.6 })
          );
          baseMid.position.y = 0.78;
          group.add(baseMid);

          const baseUpper = new THREE.Mesh(
            new THREE.CylinderGeometry(3.6, 4.2, 0.45, 64),
            new THREE.MeshStandardMaterial({ color: 0x415cd2, metalness: 0.45, roughness: 0.48, emissive: 0x172c74, emissiveIntensity: 0.2 })
          );
          baseUpper.position.y = 1.35;
          group.add(baseUpper);

          const terrace = new THREE.Mesh(
            new THREE.BoxGeometry(6.2, 0.38, 3.1),
            new THREE.MeshStandardMaterial({ color: 0x4f6ef0, metalness: 0.42, roughness: 0.45 })
          );
          terrace.position.set(0.2, 1.8, 0.4);
          terrace.rotation.y = 0.18;
          group.add(terrace);
          registerHeroPiece(terrace, { offset: new THREE.Vector3(0.6, 0.7, -0.6), rotation: new THREE.Euler(0.08, 0.18, -0.04) });

          const backdropWall = new THREE.Mesh(
            new THREE.PlaneGeometry(5.4, 3.1),
            new THREE.MeshStandardMaterial({ color: 0xe8ecff, metalness: 0.1, roughness: 0.92 })
          );
          backdropWall.position.set(0.6, 3.05, -1.3);
          backdropWall.rotation.y = 0.32;
          group.add(backdropWall);
          registerHeroPiece(backdropWall, { offset: new THREE.Vector3(0.3, 0.8, -0.35), rotation: new THREE.Euler(0.05, 0.3, 0) });

          const neonPanel = new THREE.Mesh(
            new THREE.PlaneGeometry(3.2, 1.4),
            new THREE.MeshStandardMaterial({ color: 0xd9f2ff, emissive: 0x63dfff, emissiveIntensity: 0.6, metalness: 0.08, roughness: 0.2 })
          );
          neonPanel.position.set(1.1, 2.9, -1.1);
          neonPanel.rotation.y = 0.32;
          group.add(neonPanel);
          registerHeroPiece(neonPanel, { offset: new THREE.Vector3(0.4, 0.9, -0.4), rotation: new THREE.Euler(0.1, 0.32, 0.08) });

          const archPillar = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 2.6, 2.6),
            new THREE.MeshStandardMaterial({ color: 0x7c8dff, metalness: 0.28, roughness: 0.52 })
          );
          archPillar.position.set(-0.6, 2.4, -0.7);
          group.add(archPillar);
          registerHeroPiece(archPillar, { offset: new THREE.Vector3(-0.2, 0.7, -0.2) });

          const arch = new THREE.Mesh(
            new THREE.TorusGeometry(1.4, 0.18, 32, 120, Math.PI),
            new THREE.MeshStandardMaterial({ color: 0x9ca9ff, metalness: 0.22, roughness: 0.48 })
          );
          arch.rotation.set(Math.PI / 2, 0, Math.PI);
          arch.position.set(-0.6, 2.9, -0.7);
          group.add(arch);
          registerHeroPiece(arch, { offset: new THREE.Vector3(-0.2, 0.9, -0.15), rotation: new THREE.Euler(0.15, 0.1, 0.1) });

          const vine = new THREE.Mesh(
            new THREE.PlaneGeometry(0.6, 1.8, 1, 9),
            new THREE.MeshStandardMaterial({ color: 0x6ef8b4, transparent: true, opacity: 0.78, side: THREE.DoubleSide })
          );
          vine.position.set(-1.1, 2.2, -0.9);
          vine.rotation.y = -0.12;
          group.add(vine);
          registerHeroPiece(vine, { offset: new THREE.Vector3(-0.25, 0.8, -0.3), rotation: new THREE.Euler(0.2, -0.1, 0.15) });

          const loungeSeat = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.6, 1.8, 12, 24),
            new THREE.MeshStandardMaterial({ color: 0xff9f70, roughness: 0.58, metalness: 0.18 })
          );
          loungeSeat.rotation.set(Math.PI / 2, 0.4, 0.2);
          loungeSeat.position.set(-1.4, 1.7, 0.42);
          group.add(loungeSeat);
          registerHeroPiece(loungeSeat, { offset: new THREE.Vector3(-0.6, 0.6, 0.65), rotation: new THREE.Euler(0.3, 0.4, -0.2) });

          const loungeBack = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.52, 1.2, 10, 22),
            new THREE.MeshStandardMaterial({ color: 0xffb482, roughness: 0.55, metalness: 0.2 })
          );
          loungeBack.rotation.set(Math.PI / 2, -0.6, -0.18);
          loungeBack.position.set(-1.1, 2.1, -0.05);
          group.add(loungeBack);
          registerHeroPiece(loungeBack, { offset: new THREE.Vector3(-0.38, 0.55, 0.48), rotation: new THREE.Euler(0.2, -0.25, 0.12) });

          const laptopBase = new THREE.Mesh(
            new THREE.BoxGeometry(0.96, 0.08, 0.66),
            new THREE.MeshStandardMaterial({ color: 0x172341, roughness: 0.24, metalness: 0.7 })
          );
          laptopBase.position.set(-0.28, 2.0, 0.65);
          laptopBase.rotation.set(-0.22, 0.34, 0.04);
          group.add(laptopBase);
          registerHeroPiece(laptopBase, { offset: new THREE.Vector3(0.22, 0.52, 0.44), rotation: new THREE.Euler(-0.12, 0.18, -0.08) });

          const laptopScreen = new THREE.Mesh(
            new THREE.BoxGeometry(0.92, 0.58, 0.05),
            new THREE.MeshStandardMaterial({ color: 0xa7e2ff, emissive: 0x5ad6ff, emissiveIntensity: 0.65, roughness: 0.22 })
          );
          laptopScreen.position.set(-0.12, 2.28, 0.58);
          laptopScreen.rotation.set(1.22, 0.34, 0.04);
          group.add(laptopScreen);
          registerHeroPiece(laptopScreen, { offset: new THREE.Vector3(0.26, 0.65, 0.5), rotation: new THREE.Euler(0.2, 0.22, 0.12) });

          const plantStand = new THREE.Mesh(
            new THREE.CylinderGeometry(0.82, 0.86, 0.16, 32),
            new THREE.MeshStandardMaterial({ color: 0xdbc9ff, metalness: 0.3, roughness: 0.4 })
          );
          plantStand.position.set(0.9, 1.85, 1.0);
          group.add(plantStand);
          registerHeroPiece(plantStand, { offset: new THREE.Vector3(0.6, 0.45, 0.5), rotation: new THREE.Euler(0.1, -0.18, 0.1) });

          const plantPot = new THREE.Mesh(
            new THREE.ConeGeometry(0.42, 0.9, 24),
            new THREE.MeshStandardMaterial({ color: 0xf1f6ff, metalness: 0.1, roughness: 0.5 })
          );
          plantPot.position.set(0.9, 2.22, 1.0);
          group.add(plantPot);
          registerHeroPiece(plantPot, { offset: new THREE.Vector3(0.44, 0.62, 0.55) });

          const foliage = new THREE.Mesh(
            new THREE.ConeGeometry(0.7, 1.3, 32, 1, true),
            new THREE.MeshStandardMaterial({ color: 0x7fffbe, transparent: true, opacity: 0.78, side: THREE.DoubleSide })
          );
          foliage.position.set(0.9, 2.68, 1.0);
          group.add(foliage);
          registerHeroPiece(foliage, { offset: new THREE.Vector3(0.38, 0.85, 0.6), rotation: new THREE.Euler(-0.2, 0.12, -0.08) });

          const toolkit = new THREE.Mesh(
            new THREE.CylinderGeometry(0.38, 0.38, 0.12, 24),
            heroBadgeMaterial.clone()
          );
          toolkit.position.set(1.6, 1.95, -0.32);
          group.add(toolkit);
          registerHeroPiece(toolkit, { offset: new THREE.Vector3(0.5, 0.48, -0.2), rotation: new THREE.Euler(-0.18, 0.22, 0.15) });

          const stylus = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 0.9, 16),
            new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.4, roughness: 0.3 })
          );
          stylus.rotation.set(0.12, 0, -0.6);
          stylus.position.set(1.5, 2.08, -0.32);
          group.add(stylus);
          registerHeroPiece(stylus, { offset: new THREE.Vector3(0.4, 0.5, -0.35), rotation: new THREE.Euler(0.4, 0.1, -0.3) });

          const heroHotspot = new THREE.Mesh(
            new THREE.CircleGeometry(3.0, 72),
            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.03, depthWrite: false })
          );
          heroHotspot.rotation.x = -Math.PI / 2;
          heroHotspot.position.set(0.2, 1.15, 0.4);
          group.add(heroHotspot);

          registerInteractive(heroHotspot, {
            id: 'resume-hub',
            onHover: isHovering => {
              heroBadgeMaterial.emissiveIntensity = isHovering ? 1.15 : 0.45;
            },
            onClick: () => window.open('/Adam_Shanti_Resume.pdf', '_blank', 'noopener')
          });

          return group;
        };

        const buildInterceptorIsland = () => {
          const group = new THREE.Group();

          const base = new THREE.Mesh(
            new THREE.CylinderGeometry(2.4, 2.9, 0.36, 64),
            new THREE.MeshStandardMaterial({ color: 0x253554, metalness: 0.42, roughness: 0.62 })
          );
          base.position.y = 0.18;
          group.add(base);

          const deck = new THREE.Mesh(
            new THREE.CylinderGeometry(2.1, 2.35, 0.26, 64),
            new THREE.MeshStandardMaterial({ color: 0x4a63c0, metalness: 0.46, roughness: 0.45 })
          );
          deck.position.y = 0.5;
          group.add(deck);

          const runway = new THREE.Mesh(
            new THREE.BoxGeometry(3.6, 0.08, 1.4),
            new THREE.MeshStandardMaterial({ color: 0x273b7a, metalness: 0.34, roughness: 0.5 })
          );
          runway.position.set(0.2, 0.92, -0.05);
          runway.rotation.y = 0.18;
          group.add(runway);

          const nose = new THREE.Mesh(
            new THREE.ConeGeometry(0.22, 0.8, 24),
            new THREE.MeshStandardMaterial({ color: 0xffd274, metalness: 0.5, roughness: 0.32 })
          );
          nose.rotation.set(Math.PI / 2, 0, 0.05);
          nose.position.set(1.36, 1.16, 0.06);
          group.add(nose);

          const fuselage = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.28, 1.6, 20, 32),
            new THREE.MeshStandardMaterial({ color: 0xcadfff, metalness: 0.62, roughness: 0.24 })
          );
          fuselage.rotation.set(Math.PI / 2, 0.18, 0.02);
          fuselage.position.set(0.3, 1.16, 0.02);
          group.add(fuselage);

          const wing = new THREE.Mesh(
            new THREE.BoxGeometry(2.4, 0.1, 1.2),
            new THREE.MeshStandardMaterial({ color: 0x6d86ff, metalness: 0.52, roughness: 0.34 })
          );
          wing.rotation.set(0.1, 0.02, 0.22);
          wing.position.set(-0.22, 1.02, -0.18);
          group.add(wing);

          const tail = new THREE.Mesh(
            new THREE.BoxGeometry(0.18, 0.9, 0.9),
            new THREE.MeshStandardMaterial({ color: 0x3d4f8c, metalness: 0.4, roughness: 0.38 })
          );
          tail.rotation.set(0, 0.32, 0);
          tail.position.set(-1.12, 1.42, -0.18);
          group.add(tail);

          const engine = new THREE.Mesh(
            new THREE.CylinderGeometry(0.18, 0.22, 0.9, 24),
            new THREE.MeshStandardMaterial({ color: 0x1c2748, metalness: 0.48, roughness: 0.34 })
          );
          engine.rotation.set(Math.PI / 2, 0, 0.1);
          engine.position.set(-0.76, 1.16, 0.2);
          group.add(engine);

          const exhaust = new THREE.Mesh(
            new THREE.ConeGeometry(0.24, 0.5, 24),
            new THREE.MeshStandardMaterial({ color: 0xff8b56, emissive: 0xff6323, emissiveIntensity: 0.4, transparent: true, opacity: 0.8 })
          );
          exhaust.rotation.set(Math.PI / 2, 0, 0.1);
          exhaust.position.set(-1.26, 1.02, 0.22);
          group.add(exhaust);

          const victoryFlag = new THREE.Mesh(
            new THREE.BoxGeometry(0.04, 0.64, 0.04),
            new THREE.MeshStandardMaterial({ color: 0xf9d17a, metalness: 0.32, roughness: 0.5 })
          );
          victoryFlag.position.set(0.82, 1.22, -0.6);
          group.add(victoryFlag);

          const flagBanner = new THREE.Mesh(
            new THREE.PlaneGeometry(0.6, 0.28),
            new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide })
          );
          flagBanner.position.set(0.82, 1.38, -0.6);
          flagBanner.rotation.y = 0.4;
          group.add(flagBanner);

          return group;
        };
        const buildMk4Island = () => {
          const group = new THREE.Group();

          const base = new THREE.Mesh(
            new THREE.CylinderGeometry(2.2, 2.6, 0.34, 60),
            new THREE.MeshStandardMaterial({ color: 0x223651, metalness: 0.4, roughness: 0.62 })
          );
          base.position.y = 0.17;
          group.add(base);

          const deck = new THREE.Mesh(
            new THREE.CylinderGeometry(2.0, 2.18, 0.24, 60),
            new THREE.MeshStandardMaterial({ color: 0x3f6dd0, metalness: 0.46, roughness: 0.42 })
          );
          deck.position.y = 0.46;
          group.add(deck);

          const table = new THREE.Mesh(
            new THREE.CylinderGeometry(0.4, 0.6, 0.6, 20),
            new THREE.MeshStandardMaterial({ color: 0x242c4f, metalness: 0.38, roughness: 0.4 })
          );
          table.position.set(0, 0.98, 0);
          group.add(table);

          const core = new THREE.Mesh(
            new THREE.SphereGeometry(0.32, 24, 24),
            new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.6, roughness: 0.2 })
          );
          core.position.set(0, 1.3, 0);
          group.add(core);

          const armMaterial = new THREE.MeshStandardMaterial({ color: 0x84aaff, metalness: 0.55, roughness: 0.28 });
          for (let i = 0; i < 4; i += 1) {
            const arm = new THREE.Mesh(
              new THREE.BoxGeometry(1.18, 0.12, 0.18),
              armMaterial
            );
            arm.position.set(0, 1.3, 0);
            arm.rotation.y = (Math.PI / 2) * i;
            group.add(arm);

            const rotor = new THREE.Mesh(
              new THREE.TorusGeometry(0.46, 0.06, 16, 40),
              new THREE.MeshStandardMaterial({ color: 0xfdd7a5, metalness: 0.45, roughness: 0.35 })
            );
            rotor.rotation.x = Math.PI / 2;
            rotor.position.set(Math.cos((Math.PI / 2) * i) * 0.58, 1.32, Math.sin((Math.PI / 2) * i) * 0.58);
            group.add(rotor);
          }

          const landingGear = new THREE.Mesh(
            new THREE.CylinderGeometry(0.18, 0.18, 0.62, 16),
            new THREE.MeshStandardMaterial({ color: 0x2a365f, metalness: 0.35, roughness: 0.4 })
          );
          landingGear.rotation.z = Math.PI / 2;
          landingGear.position.set(0.98, 0.9, -0.16);
          group.add(landingGear);

          const controller = new THREE.Mesh(
            new THREE.BoxGeometry(0.8, 0.2, 0.4),
            new THREE.MeshStandardMaterial({ color: 0x161f3a, metalness: 0.3, roughness: 0.45 })
          );
          controller.position.set(-0.92, 0.9, 0.5);
          group.add(controller);

          const antenna = new THREE.Mesh(
            new THREE.CylinderGeometry(0.03, 0.03, 0.6, 12),
            new THREE.MeshStandardMaterial({ color: 0x9bd5ff, metalness: 0.4, roughness: 0.35 })
          );
          antenna.position.set(-0.92, 1.2, 0.5);
          group.add(antenna);

          return group;
        };
        const buildLeadingEdgeIsland = () => {
          const group = new THREE.Group();

          const base = new THREE.Mesh(
            new THREE.CylinderGeometry(2.4, 2.7, 0.32, 60),
            new THREE.MeshStandardMaterial({ color: 0x1c3a44, metalness: 0.36, roughness: 0.6 })
          );
          base.position.y = 0.16;
          group.add(base);

          const deck = new THREE.Mesh(
            new THREE.CylinderGeometry(2.1, 2.3, 0.22, 60),
            new THREE.MeshStandardMaterial({ color: 0x318f9f, metalness: 0.4, roughness: 0.4 })
          );
          deck.position.y = 0.42;
          group.add(deck);

          const wing = new THREE.Mesh(
            new THREE.BoxGeometry(2.8, 0.16, 0.78),
            new THREE.MeshStandardMaterial({ color: 0xc3f2ff, metalness: 0.5, roughness: 0.28 })
          );
          wing.position.set(0.1, 1.03, 0);
          wing.rotation.set(-0.2, 0.3, 0.08);
          group.add(wing);

          const leadingEdgeTube = new THREE.Mesh(
            new THREE.CylinderGeometry(0.14, 0.14, 2.9, 32),
            new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.6, roughness: 0.2 })
          );
          leadingEdgeTube.rotation.set(0, 0, Math.PI / 2);
          leadingEdgeTube.position.set(0.12, 1.18, 0.16);
          group.add(leadingEdgeTube);

          const mountingPost = new THREE.Mesh(
            new THREE.CylinderGeometry(0.15, 0.19, 1.0, 24),
            new THREE.MeshStandardMaterial({ color: 0x275c6a, metalness: 0.4, roughness: 0.36 })
          );
          mountingPost.position.set(-0.9, 1.02, -0.18);
          group.add(mountingPost);

          const instrumentation = new THREE.Mesh(
            new THREE.ConeGeometry(0.3, 0.6, 24),
            new THREE.MeshStandardMaterial({ color: 0x66f1ff, emissive: 0x3dd9ff, emissiveIntensity: 0.4, transparent: true, opacity: 0.7 })
          );
          instrumentation.position.set(1.1, 1.32, -0.32);
          instrumentation.rotation.set(-Math.PI / 3, -0.2, 0.28);
          group.add(instrumentation);

          const wakeIndicator = new THREE.Mesh(
            new THREE.TorusGeometry(0.42, 0.08, 18, 60),
            new THREE.MeshStandardMaterial({ color: 0x9ffbf2, emissive: 0x63f5e2, emissiveIntensity: 0.5, transparent: true, opacity: 0.8 })
          );
          wakeIndicator.rotation.x = Math.PI / 2;
          wakeIndicator.position.set(0.96, 1.48, -0.4);
          group.add(wakeIndicator);

          const measurementBoard = new THREE.Mesh(
            new THREE.PlaneGeometry(1.2, 0.8),
            new THREE.MeshStandardMaterial({ color: 0xf0f6ff, roughness: 0.4, metalness: 0.1 })
          );
          measurementBoard.position.set(-1.2, 1.4, 0.38);
          measurementBoard.rotation.set(-Math.PI / 3.2, 0.38, 0.18);
          group.add(measurementBoard);

          return group;
        };

        const heroShowcase = buildHeroShowcase();
        const heroShowcase = buildHeroShowcase();
        stage.add(heroShowcase);
        registerFloat(heroShowcase, 0.12, 0.85, 0.0008);

        const interceptorIsland = buildInterceptorIsland();
        interceptorIsland.position.set(-3.5, 0.3, -2.1);
        stage.add(interceptorIsland);
        registerFloat(interceptorIsland, 0.25, 1.12, 0.0016);

        const mk4Island = buildMk4Island();
        mk4Island.position.set(3.3, 0.35, -1.6);
        stage.add(mk4Island);
        registerFloat(mk4Island, 0.22, 0.98, -0.0014);

        const leadingEdgeIsland = buildLeadingEdgeIsland();
        leadingEdgeIsland.position.set(0.9, 0.55, 2.8);
        stage.add(leadingEdgeIsland);
        registerFloat(leadingEdgeIsland, 0.28, 0.9, 0.0012);

        const beacon = new THREE.Mesh(
          new THREE.SphereGeometry(0.42, 24, 24),
          new THREE.MeshStandardMaterial({ color: 0x63d8ff, emissive: 0x2cd4ff, emissiveIntensity: 0.6 })
        );
        beacon.position.set(-1.45, 1.68, 1.8);
        stage.add(beacon);
        registerFloat(beacon, 0.35, 1.5, 0.004);

        const beaconHalo = new THREE.Mesh(
          new THREE.RingGeometry(0.45, 0.65, 64),
          new THREE.MeshBasicMaterial({ color: 0x83f4ff, transparent: true, opacity: 0.45 })
        );
        beaconHalo.rotation.x = Math.PI / 2;
        beaconHalo.position.copy(beacon.position);
        stage.add(beaconHalo);

        const probe = new THREE.Mesh(
          new THREE.CapsuleGeometry(0.18, 0.8, 8, 16),
          new THREE.MeshStandardMaterial({ color: 0xffe69c, metalness: 0.4, roughness: 0.3 })
        );
        probe.rotation.z = -0.6;
        probe.position.set(2.1, 1.4, 1.8);
        stage.add(probe);
        registerFloat(probe, 0.2, 1.4, 0.003);

        const probeRing = new THREE.Mesh(
          new THREE.TorusGeometry(0.34, 0.05, 18, 70),
          new THREE.MeshStandardMaterial({ color: 0xffae6a, metalness: 0.5, roughness: 0.4 })
        );
        probeRing.rotation.x = Math.PI / 2;
        probeRing.position.set(2.1, 1.02, 1.8);
        stage.add(probeRing);

        const starCount = 720;
        const starGeometry = new THREE.BufferGeometry();
        const starPositions = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount; i += 1) {
          starPositions[i * 3] = (Math.random() - 0.5) * 60;
          starPositions[i * 3 + 1] = Math.random() * 28 + 4;
          starPositions[i * 3 + 2] = (Math.random() - 0.5) * 60;
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0x68b7ff, size: 0.08, transparent: true, opacity: 0.55, depthWrite: false });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        const pointer = { x: 0, y: 0 };
        const pointerTarget = { x: 0, y: 0 };
        let idleTimer = 0;

        const updatePointer = event => {
          const rect = sceneWrap.getBoundingClientRect();
          pointerTarget.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          pointerTarget.y = ((event.clientY - rect.top) / rect.height) * 2 - 1;
          idleTimer = 0;
        };

        sceneWrap.addEventListener('pointermove', updatePointer);
        sceneWrap.addEventListener('pointerdown', updatePointer);
        sceneWrap.addEventListener('pointerleave', () => {
          pointerTarget.x = 0;
          pointerTarget.y = 0;
        });

        let hoveredInteractive = null;
        let heroExplodeProgress = 0;
        const raycaster = new THREE.Raycaster();
        const rayPointer = new THREE.Vector2();

        sceneWrap.addEventListener('click', () => {
          if (hoveredInteractive && typeof hoveredInteractive.onClick === 'function') {
            hoveredInteractive.onClick();
          }
        });

        const clock = new THREE.Clock();

        function resizeRenderer() {
          const pixelRatio = Math.min(window.devicePixelRatio, 2);
          const width = canvas.clientWidth;
          const height = canvas.clientHeight;
          if (canvas.width !== Math.floor(width * pixelRatio) || canvas.height !== Math.floor(height * pixelRatio)) {
            renderer.setSize(width, height, false);
            renderer.setPixelRatio(pixelRatio);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
          }
        }

        function render() {
          resizeRenderer();
          const delta = clock.getDelta();
          const elapsed = clock.getElapsedTime();
          idleTimer += delta;

          if (scrollNeedsUpdate) {
            updateScrollTarget();
            scrollNeedsUpdate = false;
          }

          scrollProgress += (scrollProgressTarget - scrollProgress) * 0.08;
          const easedScroll = easeInOut(scrollProgress);
          const liftAmount = easedScroll * 4.6;
          stage.position.y = stageBasePosition.y + liftAmount;
          stage.position.z = stageBasePosition.z - easedScroll * 3.2;
          const scaleFactor = THREE.MathUtils.lerp(stageBaseScale || 1, (stageBaseScale || 1) * 0.76, easedScroll);
          stage.scale.setScalar(scaleFactor);

          if (centerHubEl) {
            const hubOpacity = Math.max(0, 1 - easedScroll * 1.4);
            centerHubEl.style.opacity = hubOpacity.toFixed(3);
            centerHubEl.style.transform = `translate3d(0, ${-easedScroll * 140}px, 0)`;
          }

          if (bgTitleEl) {
            const titleOpacity = Math.max(0.1, 1 - easedScroll * 1.05);
            bgTitleEl.style.opacity = titleOpacity.toFixed(3);
            bgTitleEl.style.transform = `translate3d(0, ${-easedScroll * 180}px, 0)`;
          }

          if (projectsSection) {
            const projectEase = THREE.MathUtils.clamp((scrollProgress - 0.22) / 0.55, 0, 1);
            projectsSection.style.opacity = projectEase.toFixed(3);
            projectsSection.style.transform = `translateY(${40 * (1 - projectEase)}px)`;
          }

          pointer.x += (pointerTarget.x - pointer.x) * 0.08;
          pointer.y += (pointerTarget.y - pointer.y) * 0.08;

          rayPointer.set(pointer.x, -pointer.y);
          raycaster.setFromCamera(rayPointer, camera);
          const hit = raycaster.intersectObjects(interactiveMeshes, false)[0];
          const nextInteractive = hit ? hit.object.userData.interactive : null;
          if (nextInteractive !== hoveredInteractive) {
            if (hoveredInteractive && typeof hoveredInteractive.onHover === 'function') {
              hoveredInteractive.onHover(false);
            }
            hoveredInteractive = nextInteractive || null;
            if (hoveredInteractive && typeof hoveredInteractive.onHover === 'function') {
              hoveredInteractive.onHover(true);
            }
          }

          const heroTarget = hoveredInteractive && hoveredInteractive.id === 'resume-hub' ? 1 : 0;
          heroExplodeProgress += (heroTarget - heroExplodeProgress) * 0.12;
          const heroEase = easeInOut(heroExplodeProgress);
          heroExplodePieces.forEach(piece => {
            piece.mesh.position.copy(piece.basePosition).addScaledVector(piece.offset, heroEase);
            piece.mesh.rotation.set(
              piece.baseRotation.x + piece.rotation.x * heroEase,
              piece.baseRotation.y + piece.rotation.y * heroEase,
              piece.baseRotation.z + piece.rotation.z * heroEase
            );
            if (piece.scale) {
              const targetScale = piece.baseScale.x + piece.scale * heroEase;
              piece.mesh.scale.setScalar(targetScale);
            }
          });

          if (!prefersReducedMotion.matches) {
            if (idleTimer > 6) {
              pointerTarget.x = Math.sin(elapsed * 0.25) * 0.35;
              pointerTarget.y = Math.cos(elapsed * 0.2) * 0.18;
            }

            const pointerInfluence = 1 - easedScroll;
            const targetY = -pointer.x * 0.55 * pointerInfluence;
            const targetX = THREE.MathUtils.clamp(pointer.y * 0.22, -0.2, 0.24) * pointerInfluence;
            stage.rotation.y += (targetY - stage.rotation.y) * 0.05;
            stage.rotation.x += (targetX - stage.rotation.x) * 0.05;

            floatingItems.forEach(item => {
              const bob = Math.sin(elapsed * item.speed + item.offset) * item.amplitude * (1 - easedScroll * 0.85);
              item.group.position.y = item.baseY + bob;
              if (item.spin) {
                item.group.rotation.y += item.spin * (1 - easedScroll * 0.6);
              }
            });

            auraRing.scale.setScalar(1 + Math.sin(elapsed * 0.4) * 0.04);
            beaconHalo.rotation.z += 0.01;
            probeRing.rotation.y += 0.01;
            stars.rotation.y -= 0.0003;
          } else {
            stage.rotation.x += (0 - stage.rotation.x) * 0.08;
            stage.rotation.y += (0 - stage.rotation.y) * 0.08;
          }

          renderer.render(scene, camera);
        }

        renderer.setAnimationLoop(render);

        const handleMotionChange = () => {
          if (prefersReducedMotion.matches) {
            floatingItems.forEach(item => {
              item.group.position.y = item.baseY;
            });
            pointerTarget.x = 0;
            pointerTarget.y = 0;
          }
        };

        prefersReducedMotion.addEventListener?.('change', handleMotionChange);
        prefersReducedMotion.addListener?.(handleMotionChange);

        window.addEventListener('resize', () => {
          resizeRenderer();
          requestScrollUpdate();
        });
        requestScrollUpdate();
        resizeRenderer();
      } catch (error) {
        root.classList.remove('has-webgl');
        root.classList.add('no-webgl');
        console.error('Failed to start Three.js scene:', error);
      }
    }
  </script>

</body>
</html>
